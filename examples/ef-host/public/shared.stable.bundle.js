(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["shared.stable"],{

/***/ "1ae02a0f":
/*!***********************************************!*\
  !*** ./node_modules/n-ui-foundations/main.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("const {\n  debounce,\n  throttle\n} = __webpack_require__(/*! @financial-times/o-utils/main */ \"6d36580f\");\nconst cookieStore = __webpack_require__(/*! ./js/cookies */ \"ae05e6f9\");\nconst getSpoorNumber = () => {\n  let spoorId = cookieStore.get('spoor-id').replace(/-/g, '');\n  spoorId = spoorId.substring(spoorId.length - 12, spoorId.length); // Don't overflow the int\n  return parseInt(spoorId, 16);\n};\nmodule.exports = {\n  $: function (sel, ctx) {\n    return (ctx || document).querySelector(sel);\n  },\n  $$: function (sel, ctx) {\n    return [].slice.call((ctx || document).querySelectorAll(sel));\n  },\n  debounce,\n  throttle,\n  uuid: function uuid(a) {\n    return a ? (a ^ Math.random() * 16 >> a / 4).toString(16) : ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, uuid);\n  },\n  ascii: __webpack_require__(/*! ./js/to-ascii */ \"8b3ea372\"),\n  broadcast: function (name, data) {\n    let bubbles = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    const rootEl = Element.prototype.isPrototypeOf(this) ? this : document.body;\n    let event;\n    try {\n      event = new CustomEvent(name, {\n        bubbles: bubbles,\n        cancelable: true,\n        detail: data\n      });\n    } catch (e) {\n      event = CustomEvent.initCustomEvent(name, true, true, data);\n    }\n    rootEl.dispatchEvent(event);\n  },\n  perfMark: __webpack_require__(/*! ./js/perf-mark */ \"7d23ec59\"),\n  sampleUsers: (pct, seed) => {\n    if (!seed) {\n      throw new Error('sampleUsers needs a seed string to be passed in as the second parameter');\n    }\n    const seedAsNumber = seed.split('').reduce((num, str, i) => num + Math.pow(2, i) * str.charCodeAt(0), 0);\n    return (getSpoorNumber() + seedAsNumber) % 100 < pct;\n  },\n  cookieStore,\n  createToggler: _ref => {\n    let {\n      flag = true,\n      callback\n    } = _ref;\n    return () => {\n      if (typeof callback === 'function') {\n        callback({\n          flag\n        });\n      }\n      flag = !flag;\n      return flag;\n    };\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMWFlMDJhMGYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbi11aS1mb3VuZGF0aW9ucy9tYWluLmpzP2UzMzUiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBkZWJvdW5jZSwgdGhyb3R0bGUgfSA9IHJlcXVpcmUoJ0BmaW5hbmNpYWwtdGltZXMvby11dGlscy9tYWluJyk7XG5jb25zdCBjb29raWVTdG9yZSA9IHJlcXVpcmUoJy4vanMvY29va2llcycpO1xuY29uc3QgZ2V0U3Bvb3JOdW1iZXIgPSAoKSA9PiB7XG5cdGxldCBzcG9vcklkID0gY29va2llU3RvcmUuZ2V0KCdzcG9vci1pZCcpLnJlcGxhY2UoLy0vZywgJycpO1xuXHRzcG9vcklkID0gc3Bvb3JJZC5zdWJzdHJpbmcoc3Bvb3JJZC5sZW5ndGggLSAxMiwgc3Bvb3JJZC5sZW5ndGgpOyAvLyBEb24ndCBvdmVyZmxvdyB0aGUgaW50XG5cdHJldHVybiBwYXJzZUludChzcG9vcklkLCAxNik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0JDogZnVuY3Rpb24gKHNlbCwgY3R4KSB7IHJldHVybiAoY3R4IHx8IGRvY3VtZW50KS5xdWVyeVNlbGVjdG9yKHNlbCk7IH0sXG5cdCQkOiBmdW5jdGlvbiAoc2VsLCBjdHgpIHsgcmV0dXJuIFtdLnNsaWNlLmNhbGwoKGN0eCB8fCBkb2N1bWVudCkucXVlcnlTZWxlY3RvckFsbChzZWwpKTt9LFxuXHRkZWJvdW5jZSxcblx0dGhyb3R0bGUsXG5cdHV1aWQ6IGZ1bmN0aW9uIHV1aWQgKGEpe3JldHVybiBhPyhhXk1hdGgucmFuZG9tKCkqMTY+PmEvNCkudG9TdHJpbmcoMTYpOihbMWU3XSstMWUzKy00ZTMrLThlMystMWUxMSkucmVwbGFjZSgvWzAxOF0vZyx1dWlkKTt9LFxuXHRhc2NpaTogcmVxdWlyZSgnLi9qcy90by1hc2NpaScpLFxuXHRicm9hZGNhc3Q6IGZ1bmN0aW9uIChuYW1lLCBkYXRhLCBidWJibGVzID0gdHJ1ZSkge1xuXHRcdGNvbnN0IHJvb3RFbCA9IEVsZW1lbnQucHJvdG90eXBlLmlzUHJvdG90eXBlT2YodGhpcykgPyB0aGlzIDogZG9jdW1lbnQuYm9keTtcblx0XHRsZXQgZXZlbnQ7XG5cblx0XHR0cnkge1xuXHRcdFx0ZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQobmFtZSwge2J1YmJsZXM6IGJ1YmJsZXMsIGNhbmNlbGFibGU6IHRydWUsIGRldGFpbDogZGF0YX0pO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGV2ZW50ID0gQ3VzdG9tRXZlbnQuaW5pdEN1c3RvbUV2ZW50KG5hbWUsIHRydWUsIHRydWUsIGRhdGEpO1xuXHRcdH1cblx0XHRyb290RWwuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdH0sXG5cdHBlcmZNYXJrOiByZXF1aXJlKCcuL2pzL3BlcmYtbWFyaycpLFxuXHRzYW1wbGVVc2VyczogKHBjdCwgc2VlZCkgPT4ge1xuXHRcdGlmICghc2VlZCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdzYW1wbGVVc2VycyBuZWVkcyBhIHNlZWQgc3RyaW5nIHRvIGJlIHBhc3NlZCBpbiBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlcicpO1xuXHRcdH1cblx0XHRjb25zdCBzZWVkQXNOdW1iZXIgPSBzZWVkLnNwbGl0KCcnKS5yZWR1Y2UoKG51bSwgc3RyLCBpKSA9PiBudW0gKyBNYXRoLnBvdygyLCBpKSAqIHN0ci5jaGFyQ29kZUF0KDApLCAwKTtcblx0XHRyZXR1cm4gKGdldFNwb29yTnVtYmVyKCkgKyBzZWVkQXNOdW1iZXIpICUgMTAwIDwgcGN0O1xuXHR9LFxuXHRjb29raWVTdG9yZSxcblx0Y3JlYXRlVG9nZ2xlcjogKHsgZmxhZyA9IHRydWUsIGNhbGxiYWNrIH0pID0+IHtcblx0XHRyZXR1cm4gKCkgPT4ge1xuXHRcdFx0aWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRjYWxsYmFjayh7IGZsYWcgfSk7XG5cdFx0XHR9XG5cdFx0XHRmbGFnID0gIWZsYWc7XG5cdFx0XHRyZXR1cm4gZmxhZztcblx0XHR9O1xuXHR9XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1ae02a0f\n");

/***/ }),

/***/ "3a8f0c89":
/*!**********************************************!*\
  !*** ./node_modules/n-topic-search/index.js ***!
  \**********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var ftdomdelegate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ftdomdelegate */ \"e6b19cd3\");\n/* harmony import */ var n_ui_foundations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! n-ui-foundations */ \"1ae02a0f\");\n/* harmony import */ var n_ui_foundations__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(n_ui_foundations__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _src_renderers_search_suggestions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/renderers/search-suggestions */ \"3bf79137\");\n\n\n\nlet defaultHostName = 'www.ft.com';\n\n// Check if developing locally, if we are then proxy the search api through\n// the demo application.\nconst hostname = window.location.hostname;\nif (hostname === 'localhost' || hostname === 'local.ft.com') {\n  defaultHostName = window.location.host;\n}\nfunction getNonMatcher(container) {\n  if (typeof container === 'string') {\n    return function (el) {\n      return el && el !== document && !el.matches(container);\n    };\n  }\n  return function (el) {\n    return el && el !== document && el !== container;\n  };\n}\nfunction isOutside(el, container) {\n  const doesntMatch = getNonMatcher(container);\n  while (doesntMatch(el)) {\n    el = el.parentNode;\n  }\n  return !el || el === document;\n}\nclass TopicSearch {\n  constructor(containerEl) {\n    let {\n      listComponent = _src_renderers_search_suggestions__WEBPACK_IMPORTED_MODULE_2__[\"default\"],\n      preSuggest = a => a,\n      hostName = defaultHostName,\n      errorCallback = null\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.container = containerEl;\n    this.listComponent = listComponent;\n    this.preSuggest = preSuggest;\n    this.searchEl = this.container.querySelector('[data-n-topic-search-input]');\n    this.dataSrc = `//${hostName}/search-api/suggestions?partial=`;\n    this.categories = (this.container.getAttribute('data-n-topic-search-categories') || 'tags').split(',');\n    this.itemTag = this.container.getAttribute('data-n-topic-search-item-tag') || 'a';\n    this.includeViewAllLink = this.container.hasAttribute('data-n-topic-search-view-all');\n    this.minLength = 2;\n    this.errorCallback = errorCallback;\n    this.init();\n  }\n  init() {\n    this.suggestions = [];\n    this.suggestionListContainer = document.createElement('div');\n    this.searchEl.parentNode.insertBefore(this.suggestionListContainer, this.searchEl.nextSibling);\n    this.suggestionsView = this.listComponent(this.suggestionListContainer, {\n      categories: this.categories,\n      itemTag: this.itemTag,\n      includeViewAllLink: this.includeViewAllLink,\n      searchEl: this.searchEl\n    });\n    this.searchTermHistory = [];\n    this.bodyDelegate = new ftdomdelegate__WEBPACK_IMPORTED_MODULE_0__[\"default\"](document.body);\n    this.onType = Object(n_ui_foundations__WEBPACK_IMPORTED_MODULE_1__[\"debounce\"])(this.onType, 150).bind(this);\n    this.onFocus = this.onFocus.bind(this);\n\n    // prevent scrolling when pressing up and down arrows\n    this.searchEl.addEventListener('keydown', ev => {\n      if (ev.which === 40 || ev.which === 38) {\n        ev.preventDefault();\n      }\n    });\n    this.searchEl.addEventListener('keyup', ev => {\n      switch (ev.which) {\n        case 13:\n          return;\n        // enter\n        case 9:\n          return;\n        // tab\n        case 27:\n          //esc\n          this.hide();\n          break;\n        case 40:\n          this.onDownArrow(ev);\n          break;\n        default:\n          this.onType(ev);\n          break;\n      }\n    });\n    this.searchEl.addEventListener('focus', this.onFocus);\n    this.searchEl.addEventListener('click', this.onFocus);\n\n    // prevent scrolling when pressing up and down arrows\n    this.suggestionListContainer.addEventListener('keydown', ev => {\n      if (ev.which === 40 || ev.which === 38) {\n        ev.preventDefault();\n      }\n    });\n    this.suggestionListContainer.addEventListener('keyup', ev => {\n      switch (ev.which) {\n        case 27:\n          // esc\n          this.hideAndFocusInput();\n          break;\n        case 13:\n          this.onSelect(ev);\n          break;\n        case 9:\n          return;\n        // tab\n        case 40:\n          this.onDownArrow(ev);\n          break;\n        case 38:\n          this.onUpArrow(ev);\n          break;\n        default:\n          break;\n      }\n    });\n    this.suggestionListContainer.addEventListener('click', ev => this.onSelect(ev));\n  }\n\n  // EVENT HANDLERS\n  onType() {\n    this.searchTerm = this.searchEl.value.trim();\n    this.searchTermHistory.push(this.searchTerm);\n    this.getSuggestions(this.searchTerm);\n    [].forEach.call(this.suggestionListContainer.querySelectorAll('li'), function (el) {\n      el.setAttribute('data-trackable-meta', '{\"search-term\":\"' + this.searchTerm + '\"}');\n    }.bind(this));\n  }\n  onFocus(ev) {\n    // select all of the current text\n    ev.target.setSelectionRange ? ev.target.setSelectionRange(0, ev.target.value.length) : ev.target.select();\n\n    // If the input is programmatically focussed we may not want to show the suggestions list\n    // e.g. when intentionally closing the suggestions list.\n    if (this.preventShowOnFocus) {\n      this.preventShowOnFocus = false;\n    } else {\n      this.show();\n    }\n  }\n  onDownArrow(ev) {\n    if (this.suggestionTargets.length) {\n      const position = (this.suggestionTargets.indexOf(ev.target) + 1) % this.suggestionTargets.length;\n      this.suggestionTargets[position].focus();\n    }\n    ev.preventDefault(); //disable page scrolling\n  }\n  onTab(ev) {\n    if (this.suggestionTargets.length) {\n      this.onDownArrow(ev); // functionally the same as hitting the down arrow.\n    }\n  }\n  onSelect(ev) {\n    let target = ev.target;\n    while (!target.classList.contains('n-topic-search__target')) {\n      target = target.parentNode;\n      if (target.classList.contains('n-topic-search')) {\n        // click was not on an item\n        return;\n      }\n    }\n    this.suggestionsView.handleSelection(target, ev, this);\n  }\n  onUpArrow(ev) {\n    if (this.suggestionTargets.length) {\n      const oldPosition = this.suggestionTargets.indexOf(ev.target);\n      if (oldPosition === 0) {\n        this.searchEl.focus();\n      } else {\n        this.suggestionTargets[(oldPosition - 1) % this.suggestionTargets.length].focus();\n      }\n    }\n    ev.preventDefault(); //disable page scrolling\n  }\n\n  // INTERNALS\n  getSuggestions(value) {\n    if (value.length >= this.minLength) {\n      fetch(this.dataSrc + encodeURIComponent(value)).then(response => {\n        if (!response.ok) {\n          throw new Error(response.statusText);\n        }\n        return response.json();\n      }).then(suggestions => this.suggest(this.preSuggest(suggestions))).catch(err => {\n        this.errorCallback && this.errorCallback(err);\n        setTimeout(() => {\n          throw err;\n        });\n      });\n    } else {\n      this.unsuggest();\n    }\n  }\n  isTimelyResponse(term) {\n    // handle race conditions between e.g. TRU returning slower than TRUMP\n    const index = this.searchTermHistory.indexOf(term);\n    if (index > -1) {\n      this.searchTermHistory = this.searchTermHistory.slice(index);\n      return true;\n    }\n    return false;\n  }\n  suggest(suggestions) {\n    if (!suggestions.query || !this.isTimelyResponse(suggestions.query.partial)) {\n      return;\n    }\n    this.suggestions = suggestions;\n    this.suggestionsView.setState({\n      searchTerm: this.searchTerm,\n      suggestions: this.suggestions\n    });\n    this.show();\n    this.suggestionTargets = Array.from(this.suggestionListContainer.querySelectorAll('.n-topic-search__target'));\n  }\n  unsuggest() {\n    this.hide();\n  }\n  hide() {\n    this.suggestionListContainer.setAttribute('hidden', '');\n    this.bodyDelegate.off();\n  }\n  hideAndFocusInput() {\n    // This flag is used to prevent .show() being called after shifting focus back to\n    // the input element when intending to .hide() the suggestions list.\n    this.preventShowOnFocus = true;\n    this.hide();\n    this.searchEl.focus();\n  }\n  reset() {\n    this.hide();\n    this.suggestions = [];\n    this.suggestionTargets = [];\n    this.suggestionsView.setState({\n      suggestions: {\n        tags: [],\n        equities: []\n      },\n      searchTerm: ''\n    });\n    this.searchTermHistory = [];\n    this.searchTerm = '';\n    this.searchEl.value = '';\n  }\n  show() {\n    this.suggestionListContainer.removeAttribute('hidden');\n    ['focus', 'touchstart', 'mousedown'].forEach(type => {\n      this.bodyDelegate.on(type, ev => {\n        if (isOutside(ev.target, this.container)) {\n          this.hide();\n        }\n      });\n    });\n  }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (TopicSearch);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiM2E4ZjBjODkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbi10b3BpYy1zZWFyY2gvaW5kZXguanM/ZjlkZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRGVsZWdhdGUgZnJvbSAnZnRkb21kZWxlZ2F0ZSc7XG5pbXBvcnQgeyBkZWJvdW5jZSB9IGZyb20gJ24tdWktZm91bmRhdGlvbnMnO1xuaW1wb3J0IHN1Z2dlc3Rpb25MaXN0IGZyb20gJy4vc3JjL3JlbmRlcmVycy9zZWFyY2gtc3VnZ2VzdGlvbnMnO1xuXG5sZXQgZGVmYXVsdEhvc3ROYW1lID0gJ3d3dy5mdC5jb20nO1xuXG4vLyBDaGVjayBpZiBkZXZlbG9waW5nIGxvY2FsbHksIGlmIHdlIGFyZSB0aGVuIHByb3h5IHRoZSBzZWFyY2ggYXBpIHRocm91Z2hcbi8vIHRoZSBkZW1vIGFwcGxpY2F0aW9uLlxuY29uc3QgaG9zdG5hbWUgPSB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWU7XG5pZiAoaG9zdG5hbWUgPT09ICdsb2NhbGhvc3QnIHx8IGhvc3RuYW1lID09PSAnbG9jYWwuZnQuY29tJykge1xuXHRkZWZhdWx0SG9zdE5hbWUgPSB3aW5kb3cubG9jYXRpb24uaG9zdDtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9uTWF0Y2hlciAoY29udGFpbmVyKSB7XG5cdGlmICh0eXBlb2YgY29udGFpbmVyID09PSAnc3RyaW5nJykge1xuXHRcdHJldHVybiBmdW5jdGlvbiAoZWwpIHtcblx0XHRcdHJldHVybiBlbCAmJiBlbCAhPT0gZG9jdW1lbnQgJiYgIWVsLm1hdGNoZXMoY29udGFpbmVyKTtcblx0XHR9O1xuXHR9XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChlbCkge1xuXHRcdHJldHVybiBlbCAmJiBlbCAhPT0gZG9jdW1lbnQgJiYgZWwgIT09IGNvbnRhaW5lcjtcblx0fTtcbn1cblxuZnVuY3Rpb24gaXNPdXRzaWRlIChlbCwgY29udGFpbmVyKSB7XG5cdGNvbnN0IGRvZXNudE1hdGNoID0gZ2V0Tm9uTWF0Y2hlcihjb250YWluZXIpO1xuXG5cdHdoaWxlIChkb2VzbnRNYXRjaChlbCkpIHtcblx0XHRlbCA9IGVsLnBhcmVudE5vZGU7XG5cdH1cblxuXHRyZXR1cm4gIWVsIHx8IGVsID09PSBkb2N1bWVudDtcbn1cblxuY2xhc3MgVG9waWNTZWFyY2gge1xuXHRjb25zdHJ1Y3RvciAoY29udGFpbmVyRWwsIHtcblx0XHRsaXN0Q29tcG9uZW50ID0gc3VnZ2VzdGlvbkxpc3QsXG5cdFx0cHJlU3VnZ2VzdCA9IGEgPT4gYSxcblx0XHRob3N0TmFtZSA9IGRlZmF1bHRIb3N0TmFtZSxcblx0XHRlcnJvckNhbGxiYWNrID0gbnVsbCxcblx0fSA9IHt9KSB7XG5cdFx0dGhpcy5jb250YWluZXIgPSBjb250YWluZXJFbDtcblx0XHR0aGlzLmxpc3RDb21wb25lbnQgPSBsaXN0Q29tcG9uZW50O1xuXHRcdHRoaXMucHJlU3VnZ2VzdCA9IHByZVN1Z2dlc3Q7XG5cdFx0dGhpcy5zZWFyY2hFbCA9IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLW4tdG9waWMtc2VhcmNoLWlucHV0XScpO1xuXHRcdHRoaXMuZGF0YVNyYyA9IGAvLyR7aG9zdE5hbWV9L3NlYXJjaC1hcGkvc3VnZ2VzdGlvbnM/cGFydGlhbD1gO1xuXHRcdHRoaXMuY2F0ZWdvcmllcyA9ICh0aGlzLmNvbnRhaW5lci5nZXRBdHRyaWJ1dGUoJ2RhdGEtbi10b3BpYy1zZWFyY2gtY2F0ZWdvcmllcycpIHx8ICd0YWdzJykuc3BsaXQoJywnKTtcblx0XHR0aGlzLml0ZW1UYWcgPSB0aGlzLmNvbnRhaW5lci5nZXRBdHRyaWJ1dGUoJ2RhdGEtbi10b3BpYy1zZWFyY2gtaXRlbS10YWcnKSB8fCAnYSc7XG5cdFx0dGhpcy5pbmNsdWRlVmlld0FsbExpbmsgPSB0aGlzLmNvbnRhaW5lci5oYXNBdHRyaWJ1dGUoJ2RhdGEtbi10b3BpYy1zZWFyY2gtdmlldy1hbGwnKTtcblx0XHR0aGlzLm1pbkxlbmd0aCA9IDI7XG5cdFx0dGhpcy5lcnJvckNhbGxiYWNrID0gZXJyb3JDYWxsYmFjaztcblx0XHR0aGlzLmluaXQoKTtcblx0fVxuXG5cdGluaXQgKCkge1xuXHRcdHRoaXMuc3VnZ2VzdGlvbnMgPSBbXTtcblx0XHR0aGlzLnN1Z2dlc3Rpb25MaXN0Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0dGhpcy5zZWFyY2hFbC5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLnN1Z2dlc3Rpb25MaXN0Q29udGFpbmVyLCB0aGlzLnNlYXJjaEVsLm5leHRTaWJsaW5nKTtcblxuXHRcdHRoaXMuc3VnZ2VzdGlvbnNWaWV3ID0gdGhpcy5saXN0Q29tcG9uZW50KHRoaXMuc3VnZ2VzdGlvbkxpc3RDb250YWluZXIsIHtcblx0XHRcdGNhdGVnb3JpZXM6IHRoaXMuY2F0ZWdvcmllcyxcblx0XHRcdGl0ZW1UYWc6IHRoaXMuaXRlbVRhZyxcblx0XHRcdGluY2x1ZGVWaWV3QWxsTGluazogdGhpcy5pbmNsdWRlVmlld0FsbExpbmssXG5cdFx0XHRzZWFyY2hFbDogdGhpcy5zZWFyY2hFbFxuXHRcdH0pO1xuXHRcdHRoaXMuc2VhcmNoVGVybUhpc3RvcnkgPSBbXTtcblxuXHRcdHRoaXMuYm9keURlbGVnYXRlID0gbmV3IERlbGVnYXRlKGRvY3VtZW50LmJvZHkpO1xuXHRcdHRoaXMub25UeXBlID0gZGVib3VuY2UodGhpcy5vblR5cGUsIDE1MCkuYmluZCh0aGlzKTtcblx0XHR0aGlzLm9uRm9jdXMgPSB0aGlzLm9uRm9jdXMuYmluZCh0aGlzKTtcblxuXHRcdC8vIHByZXZlbnQgc2Nyb2xsaW5nIHdoZW4gcHJlc3NpbmcgdXAgYW5kIGRvd24gYXJyb3dzXG5cdFx0dGhpcy5zZWFyY2hFbC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZXYgPT4ge1xuXHRcdFx0aWYgKGV2LndoaWNoID09PSA0MCB8fCBldi53aGljaCA9PT0gMzgpIHtcblx0XHRcdFx0ZXYucHJldmVudERlZmF1bHQoKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMuc2VhcmNoRWwuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBldiA9PiB7XG5cdFx0XHRzd2l0Y2goZXYud2hpY2gpIHtcblx0XHRcdFx0Y2FzZSAxMyA6IHJldHVybjsgLy8gZW50ZXJcblx0XHRcdFx0Y2FzZSA5IDogcmV0dXJuOyAvLyB0YWJcblx0XHRcdFx0Y2FzZSAyNzogLy9lc2Ncblx0XHRcdFx0XHR0aGlzLmhpZGUoKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSA0MCA6XG5cdFx0XHRcdFx0dGhpcy5vbkRvd25BcnJvdyhldik7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQgOlxuXHRcdFx0XHRcdHRoaXMub25UeXBlKGV2KTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMuc2VhcmNoRWwuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLm9uRm9jdXMpO1xuXHRcdHRoaXMuc2VhcmNoRWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uRm9jdXMpO1xuXG5cdFx0Ly8gcHJldmVudCBzY3JvbGxpbmcgd2hlbiBwcmVzc2luZyB1cCBhbmQgZG93biBhcnJvd3Ncblx0XHR0aGlzLnN1Z2dlc3Rpb25MaXN0Q29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBldiA9PiB7XG5cdFx0XHRpZiAoZXYud2hpY2ggPT09IDQwIHx8IGV2LndoaWNoID09PSAzOCkge1xuXHRcdFx0XHRldi5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5zdWdnZXN0aW9uTGlzdENvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIGV2ID0+IHtcblx0XHRcdHN3aXRjaChldi53aGljaCkge1xuXHRcdFx0XHRjYXNlIDI3IDogLy8gZXNjXG5cdFx0XHRcdFx0dGhpcy5oaWRlQW5kRm9jdXNJbnB1dCgpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDEzIDpcblx0XHRcdFx0XHR0aGlzLm9uU2VsZWN0KGV2KTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSA5IDogcmV0dXJuOyAvLyB0YWJcblx0XHRcdFx0Y2FzZSA0MCA6XG5cdFx0XHRcdFx0dGhpcy5vbkRvd25BcnJvdyhldik7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgMzggOlxuXHRcdFx0XHRcdHRoaXMub25VcEFycm93KGV2KTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdCA6XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR0aGlzLnN1Z2dlc3Rpb25MaXN0Q29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZXYgPT4gdGhpcy5vblNlbGVjdChldikpO1xuXG5cdH1cblxuXHQvLyBFVkVOVCBIQU5ETEVSU1xuXHRvblR5cGUgKCkge1xuXHRcdHRoaXMuc2VhcmNoVGVybSA9IHRoaXMuc2VhcmNoRWwudmFsdWUudHJpbSgpO1xuXHRcdHRoaXMuc2VhcmNoVGVybUhpc3RvcnkucHVzaCh0aGlzLnNlYXJjaFRlcm0pO1xuXHRcdHRoaXMuZ2V0U3VnZ2VzdGlvbnModGhpcy5zZWFyY2hUZXJtKTtcblx0XHRbXS5mb3JFYWNoLmNhbGwodGhpcy5zdWdnZXN0aW9uTGlzdENvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCdsaScpLCBmdW5jdGlvbiAoZWwpIHtcblx0XHRcdGVsLnNldEF0dHJpYnV0ZSgnZGF0YS10cmFja2FibGUtbWV0YScsICd7XCJzZWFyY2gtdGVybVwiOlwiJyArIHRoaXMuc2VhcmNoVGVybSArICdcIn0nKTtcblx0XHR9LmJpbmQodGhpcykpO1xuXHR9XG5cblx0b25Gb2N1cyAoZXYpIHtcblx0XHQvLyBzZWxlY3QgYWxsIG9mIHRoZSBjdXJyZW50IHRleHRcblx0XHRldi50YXJnZXQuc2V0U2VsZWN0aW9uUmFuZ2UgPyBldi50YXJnZXQuc2V0U2VsZWN0aW9uUmFuZ2UoMCwgZXYudGFyZ2V0LnZhbHVlLmxlbmd0aCkgOiBldi50YXJnZXQuc2VsZWN0KCk7XG5cblx0XHQvLyBJZiB0aGUgaW5wdXQgaXMgcHJvZ3JhbW1hdGljYWxseSBmb2N1c3NlZCB3ZSBtYXkgbm90IHdhbnQgdG8gc2hvdyB0aGUgc3VnZ2VzdGlvbnMgbGlzdFxuXHRcdC8vIGUuZy4gd2hlbiBpbnRlbnRpb25hbGx5IGNsb3NpbmcgdGhlIHN1Z2dlc3Rpb25zIGxpc3QuXG5cdFx0aWYgKHRoaXMucHJldmVudFNob3dPbkZvY3VzKSB7XG5cdFx0XHR0aGlzLnByZXZlbnRTaG93T25Gb2N1cyA9IGZhbHNlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnNob3coKTtcblx0XHR9XG5cdH1cblxuXHRvbkRvd25BcnJvdyAoZXYpIHtcblx0XHRpZiAodGhpcy5zdWdnZXN0aW9uVGFyZ2V0cy5sZW5ndGgpIHtcblx0XHRcdGNvbnN0IHBvc2l0aW9uID0gKHRoaXMuc3VnZ2VzdGlvblRhcmdldHMuaW5kZXhPZihldi50YXJnZXQpICsgMSkgJSB0aGlzLnN1Z2dlc3Rpb25UYXJnZXRzLmxlbmd0aDtcblx0XHRcdHRoaXMuc3VnZ2VzdGlvblRhcmdldHNbcG9zaXRpb25dLmZvY3VzKCk7XG5cdFx0fVxuXHRcdGV2LnByZXZlbnREZWZhdWx0KCk7IC8vZGlzYWJsZSBwYWdlIHNjcm9sbGluZ1xuXHR9XG5cblx0b25UYWIgKGV2KSB7XG5cdFx0aWYgKHRoaXMuc3VnZ2VzdGlvblRhcmdldHMubGVuZ3RoKSB7XG5cdFx0XHR0aGlzLm9uRG93bkFycm93KGV2KTsgLy8gZnVuY3Rpb25hbGx5IHRoZSBzYW1lIGFzIGhpdHRpbmcgdGhlIGRvd24gYXJyb3cuXG5cdFx0fVxuXHR9XG5cblx0b25TZWxlY3QgKGV2KSB7XG5cdFx0bGV0IHRhcmdldCA9IGV2LnRhcmdldDtcblx0XHR3aGlsZSAoIXRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ24tdG9waWMtc2VhcmNoX190YXJnZXQnKSkge1xuXHRcdFx0dGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG5cdFx0XHRpZiAodGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnbi10b3BpYy1zZWFyY2gnKSkge1xuXHRcdFx0XHQvLyBjbGljayB3YXMgbm90IG9uIGFuIGl0ZW1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLnN1Z2dlc3Rpb25zVmlldy5oYW5kbGVTZWxlY3Rpb24odGFyZ2V0LCBldiwgdGhpcyk7XG5cdH1cblxuXHRvblVwQXJyb3cgKGV2KSB7XG5cdFx0aWYgKHRoaXMuc3VnZ2VzdGlvblRhcmdldHMubGVuZ3RoKSB7XG5cdFx0XHRjb25zdCBvbGRQb3NpdGlvbiA9IHRoaXMuc3VnZ2VzdGlvblRhcmdldHMuaW5kZXhPZihldi50YXJnZXQpO1xuXHRcdFx0aWYgKG9sZFBvc2l0aW9uID09PSAwKSB7XG5cdFx0XHRcdHRoaXMuc2VhcmNoRWwuZm9jdXMoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuc3VnZ2VzdGlvblRhcmdldHNbKG9sZFBvc2l0aW9uIC0gMSkgJSB0aGlzLnN1Z2dlc3Rpb25UYXJnZXRzLmxlbmd0aF0uZm9jdXMoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZXYucHJldmVudERlZmF1bHQoKTsgLy9kaXNhYmxlIHBhZ2Ugc2Nyb2xsaW5nXG5cdH1cblxuXHQvLyBJTlRFUk5BTFNcblx0Z2V0U3VnZ2VzdGlvbnMgKHZhbHVlKSB7XG5cdFx0aWYgKHZhbHVlLmxlbmd0aCA+PSB0aGlzLm1pbkxlbmd0aCkge1xuXHRcdFx0ZmV0Y2godGhpcy5kYXRhU3JjICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSlcblx0XHRcdFx0LnRoZW4oKHJlc3BvbnNlKSA9PiB7XG5cdFx0XHRcdFx0aWYgKCFyZXNwb25zZS5vaykge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQudGhlbihzdWdnZXN0aW9ucyA9PiB0aGlzLnN1Z2dlc3QodGhpcy5wcmVTdWdnZXN0KHN1Z2dlc3Rpb25zKSkpXG5cdFx0XHRcdC5jYXRjaCgoZXJyKSA9PiB7XG5cdFx0XHRcdFx0dGhpcy5lcnJvckNhbGxiYWNrICYmIHRoaXMuZXJyb3JDYWxsYmFjayhlcnIpO1xuXHRcdFx0XHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0XHRcdFx0dGhyb3cgZXJyO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy51bnN1Z2dlc3QoKTtcblx0XHR9XG5cdH1cblxuXHRpc1RpbWVseVJlc3BvbnNlICh0ZXJtKSB7XG5cdFx0Ly8gaGFuZGxlIHJhY2UgY29uZGl0aW9ucyBiZXR3ZWVuIGUuZy4gVFJVIHJldHVybmluZyBzbG93ZXIgdGhhbiBUUlVNUFxuXHRcdGNvbnN0IGluZGV4ID0gdGhpcy5zZWFyY2hUZXJtSGlzdG9yeS5pbmRleE9mKHRlcm0pO1xuXHRcdGlmIChpbmRleCA+IC0xKSB7XG5cdFx0XHR0aGlzLnNlYXJjaFRlcm1IaXN0b3J5ID0gdGhpcy5zZWFyY2hUZXJtSGlzdG9yeS5zbGljZShpbmRleCk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0c3VnZ2VzdCAoc3VnZ2VzdGlvbnMpIHtcblxuXHRcdGlmICghc3VnZ2VzdGlvbnMucXVlcnkgfHwgIXRoaXMuaXNUaW1lbHlSZXNwb25zZShzdWdnZXN0aW9ucy5xdWVyeS5wYXJ0aWFsKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLnN1Z2dlc3Rpb25zID0gc3VnZ2VzdGlvbnM7XG5cdFx0dGhpcy5zdWdnZXN0aW9uc1ZpZXcuc2V0U3RhdGUoe1xuXHRcdFx0c2VhcmNoVGVybTogdGhpcy5zZWFyY2hUZXJtLFxuXHRcdFx0c3VnZ2VzdGlvbnM6IHRoaXMuc3VnZ2VzdGlvbnNcblx0XHR9KTtcblx0XHR0aGlzLnNob3coKTtcblx0XHR0aGlzLnN1Z2dlc3Rpb25UYXJnZXRzID0gQXJyYXkuZnJvbSh0aGlzLnN1Z2dlc3Rpb25MaXN0Q29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJy5uLXRvcGljLXNlYXJjaF9fdGFyZ2V0JykpO1xuXHR9XG5cblx0dW5zdWdnZXN0ICgpIHtcblx0XHR0aGlzLmhpZGUoKTtcblx0fVxuXG5cdGhpZGUgKCkge1xuXHRcdHRoaXMuc3VnZ2VzdGlvbkxpc3RDb250YWluZXIuc2V0QXR0cmlidXRlKCdoaWRkZW4nLCAnJyk7XG5cdFx0dGhpcy5ib2R5RGVsZWdhdGUub2ZmKCk7XG5cdH1cblxuXHRoaWRlQW5kRm9jdXNJbnB1dCAoKSB7XG5cdFx0Ly8gVGhpcyBmbGFnIGlzIHVzZWQgdG8gcHJldmVudCAuc2hvdygpIGJlaW5nIGNhbGxlZCBhZnRlciBzaGlmdGluZyBmb2N1cyBiYWNrIHRvXG5cdFx0Ly8gdGhlIGlucHV0IGVsZW1lbnQgd2hlbiBpbnRlbmRpbmcgdG8gLmhpZGUoKSB0aGUgc3VnZ2VzdGlvbnMgbGlzdC5cblx0XHR0aGlzLnByZXZlbnRTaG93T25Gb2N1cyA9IHRydWU7XG5cdFx0dGhpcy5oaWRlKCk7XG5cdFx0dGhpcy5zZWFyY2hFbC5mb2N1cygpO1xuXHR9XG5cblx0cmVzZXQgKCkge1xuXHRcdHRoaXMuaGlkZSgpO1xuXHRcdHRoaXMuc3VnZ2VzdGlvbnMgPSBbXTtcblx0XHR0aGlzLnN1Z2dlc3Rpb25UYXJnZXRzID0gW107XG5cdFx0dGhpcy5zdWdnZXN0aW9uc1ZpZXcuc2V0U3RhdGUoe1xuXHRcdFx0c3VnZ2VzdGlvbnM6IHtcblx0XHRcdFx0dGFnczogW10sXG5cdFx0XHRcdGVxdWl0aWVzOiBbXVxuXHRcdFx0fSxcblx0XHRcdHNlYXJjaFRlcm06ICcnXG5cdFx0fSk7XG5cdFx0dGhpcy5zZWFyY2hUZXJtSGlzdG9yeSA9IFtdO1xuXHRcdHRoaXMuc2VhcmNoVGVybSA9ICcnO1xuXHRcdHRoaXMuc2VhcmNoRWwudmFsdWUgPSAnJztcblx0fVxuXG5cdHNob3cgKCkge1xuXHRcdHRoaXMuc3VnZ2VzdGlvbkxpc3RDb250YWluZXIucmVtb3ZlQXR0cmlidXRlKCdoaWRkZW4nKTtcblx0XHRbJ2ZvY3VzJywgJ3RvdWNoc3RhcnQnLCAnbW91c2Vkb3duJ11cblx0XHRcdC5mb3JFYWNoKHR5cGUgPT4ge1xuXHRcdFx0XHR0aGlzLmJvZHlEZWxlZ2F0ZS5vbih0eXBlLCAoZXYpID0+IHtcblx0XHRcdFx0XHRpZiAoaXNPdXRzaWRlKGV2LnRhcmdldCwgdGhpcy5jb250YWluZXIpKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmhpZGUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVG9waWNTZWFyY2g7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFLQTtBQUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3a8f0c89\n");

/***/ }),

/***/ "3bf79137":
/*!*************************************************************************!*\
  !*** ./node_modules/n-topic-search/src/renderers/search-suggestions.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _base_renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base-renderer */ \"ae50df7e\");\nconst DISPLAY_ITEMS = 5;\n\nconst headingMapping = {\n  concepts: 'News',\n  equities: 'Securities'\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (container, options) {\n  return new SuggestionList(container, options);\n});\nclass SuggestionList extends _base_renderer__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  constructor(container, options) {\n    super(container, options);\n    this.renderSuggestionGroup = this.renderSuggestionGroup.bind(this);\n    this.createHtml();\n    this.render();\n  }\n  renderTailLink(group) {\n    if (group.tailLink) {\n      const linkAttrs = `\n\t\t\t\tclass=\"n-topic-search__target n-topic-search__target--tail\"\n\t\t\t\thref=\"${group.tailLink.url}\"\n\t\t\t\tdata-trackable=\"${group.tailLink.trackable}\"\"\n\t\t\t`;\n      return `<a ${linkAttrs} tabindex=\"0\">${group.tailLink.innerHtml}</a>`;\n    }\n  }\n  renderSuggestionLink(suggestion, group) {\n    return `<li class=\"n-topic-search__item\">\n\t\t\t<a class=\"n-topic-search__target ${group.linkClassName}\"\n\t\t\t\thref=\"${suggestion.url}\"\n\t\t\t\ttabindex=\"0\"\n\t\t\t\tdata-trackable=\"link\"\n\t\t\t\tdata-suggestion-id=\"${suggestion.id}\"\n\t\t\t\tdata-suggestion-type=\"${suggestion.type}\"\n\t\t\t>${suggestion.html}</a>\n\t\t</li>`;\n  }\n  renderSuggestionGroup(group) {\n    let html = `<div class=\"n-topic-search__group ${group.className}\" data-trackable=\"${group.trackable}\">`;\n    html += this.options.categories.length > 1 ? `<div class=\"n-topic-search__heading\">${group.heading}</div>` : '';\n    if (group.suggestions.length || group.emptyHtml) {\n      html += `<ul class=\"n-topic-search__item-list\">\n\t\t\t\t${group.suggestions.map(suggestion => this.renderSuggestionLink(suggestion, group)).join('')}\n\t\t\t\t<li class=\"n-topic-search__item\">\n\t\t\t\t\t${this.renderTailLink(group)}\n\t\t\t\t</li>\n\t\t\t</ul>`;\n    }\n    html += '</div>';\n    return html;\n  }\n  createHtml() {\n    const hasConcepts = this.state.suggestions.concepts && this.state.suggestions.concepts.length;\n    const hasEquities = this.state.suggestions.equities && this.state.suggestions.equities.length;\n    const hasSuggestions = hasConcepts || hasEquities;\n    const suggestions = [];\n    this.items = [];\n    if (this.options.categories.includes('concepts')) {\n      suggestions.push({\n        heading: headingMapping['concepts'],\n        linkClassName: 'n-topic-search__target--news',\n        trackable: 'news',\n        suggestions: this.state.suggestions.concepts.slice(0, DISPLAY_ITEMS).map(suggestion => ({\n          html: this.highlight(suggestion.prefLabel),\n          url: suggestion.url,\n          id: suggestion.id,\n          type: 'tag'\n        })),\n        tailLink: this.options.includeViewAllLink && {\n          url: `/search?q=${this.state.searchTerm}`,\n          innerHtml: `<span>See all news matching <mark>${this.state.searchTerm}</mark></span>`,\n          trackable: 'see-all'\n        }\n      });\n    }\n    if (this.options.categories.includes('equities')) {\n      suggestions.push({\n        heading: headingMapping['equities'],\n        trackable: 'equities',\n        linkClassName: 'n-topic-search__target--equities',\n        emptyHtml: '<div className=\"n-topic-search__no-results-message\">No equities found</div>',\n        suggestions: this.state.suggestions.equities.slice(0, DISPLAY_ITEMS).map(suggestion => ({\n          html: `<span class=\"n-topic-search__target__equity-name\">${this.highlight(suggestion.name)}</span><abbr>${this.highlight(suggestion.symbol)}</abbr>`,\n          url: suggestion.url,\n          id: suggestion.symbol,\n          type: 'equity'\n        })),\n        tailLink: this.options.includeViewAllLink && {\n          url: `https://markets.ft.com/data/search?query=${this.state.searchTerm}`,\n          innerHtml: `<span>See all quotes matching <mark>${this.state.searchTerm}</mark></span>`,\n          trackable: 'see-all'\n        }\n      });\n    }\n    this.newHtml = `\n\t\t\t<div aria-live=\"assertive\">\n\t\t\t\t${hasSuggestions ? `<div\n\t\t\t\t\tclass=\"o-normalise-visually-hidden n-topic-search__suggestions_explanation\">\n\t\t\t\t\tSearch results have been displayed. To jump to the list of suggestions press the down arrow key.\n\t\t\t\t</div>` : ''}\n\t\t\t\t<div\n\t\t\t\t\tclass=\"n-topic-search n-topic-search__suggestions\"\n\t\t\t\t\t${hasSuggestions ? '' : 'hidden'}\n\t\t\t\t\tdata-trackable=\"typeahead\"\n\t\t\t\t>\n\t\t\t\t\t<div class=\"o-normalise-visually-hidden\">Suggestions include</div>\n\t\t\t\t\t${suggestions.map(this.renderSuggestionGroup).join('')}\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t`;\n  }\n  handleSelection(el, ev) {\n    ev.stopPropagation();\n    // we don't prevent default as the link's url is a link to the relevant stream page\n    return;\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiM2JmNzkxMzcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbi10b3BpYy1zZWFyY2gvc3JjL3JlbmRlcmVycy9zZWFyY2gtc3VnZ2VzdGlvbnMuanM/ZWRlOCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBESVNQTEFZX0lURU1TID0gNTtcbmltcG9ydCBCYXNlUmVuZGVyZXIgZnJvbSAnLi9iYXNlLXJlbmRlcmVyJztcblxuY29uc3QgaGVhZGluZ01hcHBpbmcgPSB7XG5cdGNvbmNlcHRzOiAnTmV3cycsXG5cdGVxdWl0aWVzOiAnU2VjdXJpdGllcydcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChjb250YWluZXIsIG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBTdWdnZXN0aW9uTGlzdChjb250YWluZXIsIG9wdGlvbnMpO1xufVxuXG5jbGFzcyBTdWdnZXN0aW9uTGlzdCBleHRlbmRzIEJhc2VSZW5kZXJlciB7XG5cdGNvbnN0cnVjdG9yIChjb250YWluZXIsIG9wdGlvbnMpIHtcblx0XHRzdXBlcihjb250YWluZXIsIG9wdGlvbnMpO1xuXHRcdHRoaXMucmVuZGVyU3VnZ2VzdGlvbkdyb3VwID0gdGhpcy5yZW5kZXJTdWdnZXN0aW9uR3JvdXAuYmluZCh0aGlzKTtcblx0XHR0aGlzLmNyZWF0ZUh0bWwoKTtcblx0XHR0aGlzLnJlbmRlcigpO1xuXHR9XG5cblx0cmVuZGVyVGFpbExpbmsgKGdyb3VwKSB7XG5cdFx0aWYgKGdyb3VwLnRhaWxMaW5rKSB7XG5cdFx0XHRjb25zdCBsaW5rQXR0cnMgPSBgXG5cdFx0XHRcdGNsYXNzPVwibi10b3BpYy1zZWFyY2hfX3RhcmdldCBuLXRvcGljLXNlYXJjaF9fdGFyZ2V0LS10YWlsXCJcblx0XHRcdFx0aHJlZj1cIiR7Z3JvdXAudGFpbExpbmsudXJsfVwiXG5cdFx0XHRcdGRhdGEtdHJhY2thYmxlPVwiJHtncm91cC50YWlsTGluay50cmFja2FibGV9XCJcIlxuXHRcdFx0YDtcblx0XHRcdHJldHVybiBgPGEgJHtsaW5rQXR0cnN9IHRhYmluZGV4PVwiMFwiPiR7Z3JvdXAudGFpbExpbmsuaW5uZXJIdG1sfTwvYT5gO1xuXHRcdH1cblx0fVxuXG5cdHJlbmRlclN1Z2dlc3Rpb25MaW5rIChzdWdnZXN0aW9uLCBncm91cCkge1xuXHRcdHJldHVybiBgPGxpIGNsYXNzPVwibi10b3BpYy1zZWFyY2hfX2l0ZW1cIj5cblx0XHRcdDxhIGNsYXNzPVwibi10b3BpYy1zZWFyY2hfX3RhcmdldCAke2dyb3VwLmxpbmtDbGFzc05hbWV9XCJcblx0XHRcdFx0aHJlZj1cIiR7c3VnZ2VzdGlvbi51cmx9XCJcblx0XHRcdFx0dGFiaW5kZXg9XCIwXCJcblx0XHRcdFx0ZGF0YS10cmFja2FibGU9XCJsaW5rXCJcblx0XHRcdFx0ZGF0YS1zdWdnZXN0aW9uLWlkPVwiJHtzdWdnZXN0aW9uLmlkfVwiXG5cdFx0XHRcdGRhdGEtc3VnZ2VzdGlvbi10eXBlPVwiJHtzdWdnZXN0aW9uLnR5cGV9XCJcblx0XHRcdD4ke3N1Z2dlc3Rpb24uaHRtbH08L2E+XG5cdFx0PC9saT5gO1xuXHR9XG5cblx0cmVuZGVyU3VnZ2VzdGlvbkdyb3VwIChncm91cCkge1xuXHRcdGxldCBodG1sID0gYDxkaXYgY2xhc3M9XCJuLXRvcGljLXNlYXJjaF9fZ3JvdXAgJHtncm91cC5jbGFzc05hbWV9XCIgZGF0YS10cmFja2FibGU9XCIke2dyb3VwLnRyYWNrYWJsZX1cIj5gO1xuXG5cdFx0aHRtbCArPSB0aGlzLm9wdGlvbnMuY2F0ZWdvcmllcy5sZW5ndGggPiAxID8gYDxkaXYgY2xhc3M9XCJuLXRvcGljLXNlYXJjaF9faGVhZGluZ1wiPiR7Z3JvdXAuaGVhZGluZ308L2Rpdj5gIDogJyc7XG5cblx0XHRpZiAoZ3JvdXAuc3VnZ2VzdGlvbnMubGVuZ3RoIHx8IGdyb3VwLmVtcHR5SHRtbCkge1xuXHRcdFx0aHRtbCArPSBgPHVsIGNsYXNzPVwibi10b3BpYy1zZWFyY2hfX2l0ZW0tbGlzdFwiPlxuXHRcdFx0XHQke2dyb3VwLnN1Z2dlc3Rpb25zLm1hcChzdWdnZXN0aW9uID0+IHRoaXMucmVuZGVyU3VnZ2VzdGlvbkxpbmsoc3VnZ2VzdGlvbiwgZ3JvdXApKS5qb2luKCcnKX1cblx0XHRcdFx0PGxpIGNsYXNzPVwibi10b3BpYy1zZWFyY2hfX2l0ZW1cIj5cblx0XHRcdFx0XHQke3RoaXMucmVuZGVyVGFpbExpbmsoZ3JvdXApfVxuXHRcdFx0XHQ8L2xpPlxuXHRcdFx0PC91bD5gO1xuXHRcdH1cblx0XHRodG1sICs9ICc8L2Rpdj4nO1xuXHRcdHJldHVybiBodG1sO1xuXHR9XG5cblx0Y3JlYXRlSHRtbCAoKSB7XG5cblx0XHRjb25zdCBoYXNDb25jZXB0cyA9IHRoaXMuc3RhdGUuc3VnZ2VzdGlvbnMuY29uY2VwdHMgJiYgdGhpcy5zdGF0ZS5zdWdnZXN0aW9ucy5jb25jZXB0cy5sZW5ndGg7XG5cdFx0Y29uc3QgaGFzRXF1aXRpZXMgPSB0aGlzLnN0YXRlLnN1Z2dlc3Rpb25zLmVxdWl0aWVzICYmIHRoaXMuc3RhdGUuc3VnZ2VzdGlvbnMuZXF1aXRpZXMubGVuZ3RoO1xuXHRcdGNvbnN0IGhhc1N1Z2dlc3Rpb25zID0gaGFzQ29uY2VwdHMgfHwgaGFzRXF1aXRpZXM7XG5cdFx0Y29uc3Qgc3VnZ2VzdGlvbnMgPSBbXTtcblx0XHR0aGlzLml0ZW1zID0gW107XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jYXRlZ29yaWVzLmluY2x1ZGVzKCdjb25jZXB0cycpKSB7XG5cdFx0XHRzdWdnZXN0aW9ucy5wdXNoKHtcblx0XHRcdFx0aGVhZGluZzogaGVhZGluZ01hcHBpbmdbJ2NvbmNlcHRzJ10sXG5cdFx0XHRcdGxpbmtDbGFzc05hbWU6ICduLXRvcGljLXNlYXJjaF9fdGFyZ2V0LS1uZXdzJyxcblx0XHRcdFx0dHJhY2thYmxlOiAnbmV3cycsXG5cdFx0XHRcdHN1Z2dlc3Rpb25zOiB0aGlzLnN0YXRlLnN1Z2dlc3Rpb25zLmNvbmNlcHRzLnNsaWNlKDAsIERJU1BMQVlfSVRFTVMpXG5cdFx0XHRcdFx0Lm1hcChzdWdnZXN0aW9uID0+ICh7XG5cdFx0XHRcdFx0XHRodG1sOiB0aGlzLmhpZ2hsaWdodChzdWdnZXN0aW9uLnByZWZMYWJlbCksXG5cdFx0XHRcdFx0XHR1cmw6IHN1Z2dlc3Rpb24udXJsLFxuXHRcdFx0XHRcdFx0aWQ6IHN1Z2dlc3Rpb24uaWQsXG5cdFx0XHRcdFx0XHR0eXBlOiAndGFnJ1xuXHRcdFx0XHRcdH0pKSxcblx0XHRcdFx0dGFpbExpbms6IHRoaXMub3B0aW9ucy5pbmNsdWRlVmlld0FsbExpbmsgJiYge1xuXHRcdFx0XHRcdHVybDogYC9zZWFyY2g/cT0ke3RoaXMuc3RhdGUuc2VhcmNoVGVybX1gLFxuXHRcdFx0XHRcdGlubmVySHRtbDogYDxzcGFuPlNlZSBhbGwgbmV3cyBtYXRjaGluZyA8bWFyaz4ke3RoaXMuc3RhdGUuc2VhcmNoVGVybX08L21hcms+PC9zcGFuPmAsXG5cdFx0XHRcdFx0dHJhY2thYmxlOiAnc2VlLWFsbCdcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHR9XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLmNhdGVnb3JpZXMuaW5jbHVkZXMoJ2VxdWl0aWVzJykpIHtcblx0XHRcdHN1Z2dlc3Rpb25zLnB1c2goe1xuXHRcdFx0XHRoZWFkaW5nOiBoZWFkaW5nTWFwcGluZ1snZXF1aXRpZXMnXSxcblx0XHRcdFx0dHJhY2thYmxlOiAnZXF1aXRpZXMnLFxuXHRcdFx0XHRsaW5rQ2xhc3NOYW1lOiAnbi10b3BpYy1zZWFyY2hfX3RhcmdldC0tZXF1aXRpZXMnLFxuXHRcdFx0XHRlbXB0eUh0bWw6ICc8ZGl2IGNsYXNzTmFtZT1cIm4tdG9waWMtc2VhcmNoX19uby1yZXN1bHRzLW1lc3NhZ2VcIj5ObyBlcXVpdGllcyBmb3VuZDwvZGl2PicsXG5cdFx0XHRcdHN1Z2dlc3Rpb25zOiB0aGlzLnN0YXRlLnN1Z2dlc3Rpb25zLmVxdWl0aWVzLnNsaWNlKDAsIERJU1BMQVlfSVRFTVMpXG5cdFx0XHRcdFx0Lm1hcChzdWdnZXN0aW9uID0+ICh7XG5cdFx0XHRcdFx0XHRodG1sOiBgPHNwYW4gY2xhc3M9XCJuLXRvcGljLXNlYXJjaF9fdGFyZ2V0X19lcXVpdHktbmFtZVwiPiR7dGhpcy5oaWdobGlnaHQoc3VnZ2VzdGlvbi5uYW1lKX08L3NwYW4+PGFiYnI+JHt0aGlzLmhpZ2hsaWdodChzdWdnZXN0aW9uLnN5bWJvbCl9PC9hYmJyPmAsXG5cdFx0XHRcdFx0XHR1cmw6IHN1Z2dlc3Rpb24udXJsLFxuXHRcdFx0XHRcdFx0aWQ6IHN1Z2dlc3Rpb24uc3ltYm9sLFxuXHRcdFx0XHRcdFx0dHlwZTogJ2VxdWl0eSdcblx0XHRcdFx0XHR9KSksXG5cdFx0XHRcdHRhaWxMaW5rOiB0aGlzLm9wdGlvbnMuaW5jbHVkZVZpZXdBbGxMaW5rICYmIHtcblx0XHRcdFx0XHR1cmw6IGBodHRwczovL21hcmtldHMuZnQuY29tL2RhdGEvc2VhcmNoP3F1ZXJ5PSR7dGhpcy5zdGF0ZS5zZWFyY2hUZXJtfWAsXG5cdFx0XHRcdFx0aW5uZXJIdG1sOiBgPHNwYW4+U2VlIGFsbCBxdW90ZXMgbWF0Y2hpbmcgPG1hcms+JHt0aGlzLnN0YXRlLnNlYXJjaFRlcm19PC9tYXJrPjwvc3Bhbj5gLFxuXHRcdFx0XHRcdHRyYWNrYWJsZTogJ3NlZS1hbGwnXG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0XHR0aGlzLm5ld0h0bWwgPSBgXG5cdFx0XHQ8ZGl2IGFyaWEtbGl2ZT1cImFzc2VydGl2ZVwiPlxuXHRcdFx0XHQkeyBoYXNTdWdnZXN0aW9ucyA/IGA8ZGl2XG5cdFx0XHRcdFx0Y2xhc3M9XCJvLW5vcm1hbGlzZS12aXN1YWxseS1oaWRkZW4gbi10b3BpYy1zZWFyY2hfX3N1Z2dlc3Rpb25zX2V4cGxhbmF0aW9uXCI+XG5cdFx0XHRcdFx0U2VhcmNoIHJlc3VsdHMgaGF2ZSBiZWVuIGRpc3BsYXllZC4gVG8ganVtcCB0byB0aGUgbGlzdCBvZiBzdWdnZXN0aW9ucyBwcmVzcyB0aGUgZG93biBhcnJvdyBrZXkuXG5cdFx0XHRcdDwvZGl2PmAgOiAnJyB9XG5cdFx0XHRcdDxkaXZcblx0XHRcdFx0XHRjbGFzcz1cIm4tdG9waWMtc2VhcmNoIG4tdG9waWMtc2VhcmNoX19zdWdnZXN0aW9uc1wiXG5cdFx0XHRcdFx0JHsgaGFzU3VnZ2VzdGlvbnMgPyAnJyA6ICdoaWRkZW4nfVxuXHRcdFx0XHRcdGRhdGEtdHJhY2thYmxlPVwidHlwZWFoZWFkXCJcblx0XHRcdFx0PlxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJvLW5vcm1hbGlzZS12aXN1YWxseS1oaWRkZW5cIj5TdWdnZXN0aW9ucyBpbmNsdWRlPC9kaXY+XG5cdFx0XHRcdFx0JHsgc3VnZ2VzdGlvbnMubWFwKHRoaXMucmVuZGVyU3VnZ2VzdGlvbkdyb3VwKS5qb2luKCcnKSB9XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0PC9kaXY+XG5cdFx0XHRgO1xuXHR9XG5cblx0aGFuZGxlU2VsZWN0aW9uIChlbCwgZXYpIHtcblx0XHRldi5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHQvLyB3ZSBkb24ndCBwcmV2ZW50IGRlZmF1bHQgYXMgdGhlIGxpbmsncyB1cmwgaXMgYSBsaW5rIHRvIHRoZSByZWxldmFudCBzdHJlYW0gcGFnZVxuXHRcdHJldHVybjtcblx0fVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3bf79137\n");

/***/ }),

/***/ "3c7622ff":
/*!**********************************************************!*\
  !*** ./node_modules/focus-visible/dist/focus-visible.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("(function (global, factory) {\n   true ? factory() : undefined;\n})(this, function () {\n  'use strict';\n\n  /**\n   * Applies the :focus-visible polyfill at the given scope.\n   * A scope in this case is either the top-level Document or a Shadow Root.\n   *\n   * @param {(Document|ShadowRoot)} scope\n   * @see https://github.com/WICG/focus-visible\n   */\n  function applyFocusVisiblePolyfill(scope) {\n    var hadKeyboardEvent = true;\n    var hadFocusVisibleRecently = false;\n    var hadFocusVisibleRecentlyTimeout = null;\n    var inputTypesAllowlist = {\n      text: true,\n      search: true,\n      url: true,\n      tel: true,\n      email: true,\n      password: true,\n      number: true,\n      date: true,\n      month: true,\n      week: true,\n      time: true,\n      datetime: true,\n      'datetime-local': true\n    };\n\n    /**\n     * Helper function for legacy browsers and iframes which sometimes focus\n     * elements like document, body, and non-interactive SVG.\n     * @param {Element} el\n     */\n    function isValidFocusTarget(el) {\n      if (el && el !== document && el.nodeName !== 'HTML' && el.nodeName !== 'BODY' && 'classList' in el && 'contains' in el.classList) {\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * Computes whether the given element should automatically trigger the\n     * `focus-visible` class being added, i.e. whether it should always match\n     * `:focus-visible` when focused.\n     * @param {Element} el\n     * @return {boolean}\n     */\n    function focusTriggersKeyboardModality(el) {\n      var type = el.type;\n      var tagName = el.tagName;\n      if (tagName === 'INPUT' && inputTypesAllowlist[type] && !el.readOnly) {\n        return true;\n      }\n      if (tagName === 'TEXTAREA' && !el.readOnly) {\n        return true;\n      }\n      if (el.isContentEditable) {\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * Add the `focus-visible` class to the given element if it was not added by\n     * the author.\n     * @param {Element} el\n     */\n    function addFocusVisibleClass(el) {\n      if (el.classList.contains('focus-visible')) {\n        return;\n      }\n      el.classList.add('focus-visible');\n      el.setAttribute('data-focus-visible-added', '');\n    }\n\n    /**\n     * Remove the `focus-visible` class from the given element if it was not\n     * originally added by the author.\n     * @param {Element} el\n     */\n    function removeFocusVisibleClass(el) {\n      if (!el.hasAttribute('data-focus-visible-added')) {\n        return;\n      }\n      el.classList.remove('focus-visible');\n      el.removeAttribute('data-focus-visible-added');\n    }\n\n    /**\n     * If the most recent user interaction was via the keyboard;\n     * and the key press did not include a meta, alt/option, or control key;\n     * then the modality is keyboard. Otherwise, the modality is not keyboard.\n     * Apply `focus-visible` to any current active element and keep track\n     * of our keyboard modality state with `hadKeyboardEvent`.\n     * @param {KeyboardEvent} e\n     */\n    function onKeyDown(e) {\n      if (e.metaKey || e.altKey || e.ctrlKey) {\n        return;\n      }\n      if (isValidFocusTarget(scope.activeElement)) {\n        addFocusVisibleClass(scope.activeElement);\n      }\n      hadKeyboardEvent = true;\n    }\n\n    /**\n     * If at any point a user clicks with a pointing device, ensure that we change\n     * the modality away from keyboard.\n     * This avoids the situation where a user presses a key on an already focused\n     * element, and then clicks on a different element, focusing it with a\n     * pointing device, while we still think we're in keyboard modality.\n     * @param {Event} e\n     */\n    function onPointerDown(e) {\n      hadKeyboardEvent = false;\n    }\n\n    /**\n     * On `focus`, add the `focus-visible` class to the target if:\n     * - the target received focus as a result of keyboard navigation, or\n     * - the event target is an element that will likely require interaction\n     *   via the keyboard (e.g. a text box)\n     * @param {Event} e\n     */\n    function onFocus(e) {\n      // Prevent IE from focusing the document or HTML element.\n      if (!isValidFocusTarget(e.target)) {\n        return;\n      }\n      if (hadKeyboardEvent || focusTriggersKeyboardModality(e.target)) {\n        addFocusVisibleClass(e.target);\n      }\n    }\n\n    /**\n     * On `blur`, remove the `focus-visible` class from the target.\n     * @param {Event} e\n     */\n    function onBlur(e) {\n      if (!isValidFocusTarget(e.target)) {\n        return;\n      }\n      if (e.target.classList.contains('focus-visible') || e.target.hasAttribute('data-focus-visible-added')) {\n        // To detect a tab/window switch, we look for a blur event followed\n        // rapidly by a visibility change.\n        // If we don't see a visibility change within 100ms, it's probably a\n        // regular focus change.\n        hadFocusVisibleRecently = true;\n        window.clearTimeout(hadFocusVisibleRecentlyTimeout);\n        hadFocusVisibleRecentlyTimeout = window.setTimeout(function () {\n          hadFocusVisibleRecently = false;\n        }, 100);\n        removeFocusVisibleClass(e.target);\n      }\n    }\n\n    /**\n     * If the user changes tabs, keep track of whether or not the previously\n     * focused element had .focus-visible.\n     * @param {Event} e\n     */\n    function onVisibilityChange(e) {\n      if (document.visibilityState === 'hidden') {\n        // If the tab becomes active again, the browser will handle calling focus\n        // on the element (Safari actually calls it twice).\n        // If this tab change caused a blur on an element with focus-visible,\n        // re-apply the class when the user switches back to the tab.\n        if (hadFocusVisibleRecently) {\n          hadKeyboardEvent = true;\n        }\n        addInitialPointerMoveListeners();\n      }\n    }\n\n    /**\n     * Add a group of listeners to detect usage of any pointing devices.\n     * These listeners will be added when the polyfill first loads, and anytime\n     * the window is blurred, so that they are active when the window regains\n     * focus.\n     */\n    function addInitialPointerMoveListeners() {\n      document.addEventListener('mousemove', onInitialPointerMove);\n      document.addEventListener('mousedown', onInitialPointerMove);\n      document.addEventListener('mouseup', onInitialPointerMove);\n      document.addEventListener('pointermove', onInitialPointerMove);\n      document.addEventListener('pointerdown', onInitialPointerMove);\n      document.addEventListener('pointerup', onInitialPointerMove);\n      document.addEventListener('touchmove', onInitialPointerMove);\n      document.addEventListener('touchstart', onInitialPointerMove);\n      document.addEventListener('touchend', onInitialPointerMove);\n    }\n    function removeInitialPointerMoveListeners() {\n      document.removeEventListener('mousemove', onInitialPointerMove);\n      document.removeEventListener('mousedown', onInitialPointerMove);\n      document.removeEventListener('mouseup', onInitialPointerMove);\n      document.removeEventListener('pointermove', onInitialPointerMove);\n      document.removeEventListener('pointerdown', onInitialPointerMove);\n      document.removeEventListener('pointerup', onInitialPointerMove);\n      document.removeEventListener('touchmove', onInitialPointerMove);\n      document.removeEventListener('touchstart', onInitialPointerMove);\n      document.removeEventListener('touchend', onInitialPointerMove);\n    }\n\n    /**\n     * When the polfyill first loads, assume the user is in keyboard modality.\n     * If any event is received from a pointing device (e.g. mouse, pointer,\n     * touch), turn off keyboard modality.\n     * This accounts for situations where focus enters the page from the URL bar.\n     * @param {Event} e\n     */\n    function onInitialPointerMove(e) {\n      // Work around a Safari quirk that fires a mousemove on <html> whenever the\n      // window blurs, even if you're tabbing out of the page. ¯\\_(ツ)_/¯\n      if (e.target.nodeName && e.target.nodeName.toLowerCase() === 'html') {\n        return;\n      }\n      hadKeyboardEvent = false;\n      removeInitialPointerMoveListeners();\n    }\n\n    // For some kinds of state, we are interested in changes at the global scope\n    // only. For example, global pointer input, global key presses and global\n    // visibility change should affect the state at every scope:\n    document.addEventListener('keydown', onKeyDown, true);\n    document.addEventListener('mousedown', onPointerDown, true);\n    document.addEventListener('pointerdown', onPointerDown, true);\n    document.addEventListener('touchstart', onPointerDown, true);\n    document.addEventListener('visibilitychange', onVisibilityChange, true);\n    addInitialPointerMoveListeners();\n\n    // For focus and blur, we specifically care about state changes in the local\n    // scope. This is because focus / blur events that originate from within a\n    // shadow root are not re-dispatched from the host element if it was already\n    // the active element in its own scope:\n    scope.addEventListener('focus', onFocus, true);\n    scope.addEventListener('blur', onBlur, true);\n\n    // We detect that a node is a ShadowRoot by ensuring that it is a\n    // DocumentFragment and also has a host property. This check covers native\n    // implementation and polyfill implementation transparently. If we only cared\n    // about the native implementation, we could just check if the scope was\n    // an instance of a ShadowRoot.\n    if (scope.nodeType === Node.DOCUMENT_FRAGMENT_NODE && scope.host) {\n      // Since a ShadowRoot is a special kind of DocumentFragment, it does not\n      // have a root element to add a class to. So, we add this attribute to the\n      // host element instead:\n      scope.host.setAttribute('data-js-focus-visible', '');\n    } else if (scope.nodeType === Node.DOCUMENT_NODE) {\n      document.documentElement.classList.add('js-focus-visible');\n      document.documentElement.setAttribute('data-js-focus-visible', '');\n    }\n  }\n\n  // It is important to wrap all references to global window and document in\n  // these checks to support server-side rendering use cases\n  // @see https://github.com/WICG/focus-visible/issues/199\n  if (typeof window !== 'undefined' && typeof document !== 'undefined') {\n    // Make the polyfill helper globally available. This can be used as a signal\n    // to interested libraries that wish to coordinate with the polyfill for e.g.,\n    // applying the polyfill to a shadow root:\n    window.applyFocusVisiblePolyfill = applyFocusVisiblePolyfill;\n\n    // Notify interested libraries of the polyfill's presence, in case the\n    // polyfill was loaded lazily:\n    var event;\n    try {\n      event = new CustomEvent('focus-visible-polyfill-ready');\n    } catch (error) {\n      // IE11 does not support using CustomEvent as a constructor directly:\n      event = document.createEvent('CustomEvent');\n      event.initCustomEvent('focus-visible-polyfill-ready', false, false, {});\n    }\n    window.dispatchEvent(event);\n  }\n  if (typeof document !== 'undefined') {\n    // Apply the polyfill to the global document, so that no JavaScript\n    // coordination is required to use the polyfill in the top-level document:\n    applyFocusVisiblePolyfill(document);\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiM2M3NjIyZmYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZm9jdXMtdmlzaWJsZS9kaXN0L2ZvY3VzLXZpc2libGUuanM/OTVmMCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KCkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAoZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoZSA6Zm9jdXMtdmlzaWJsZSBwb2x5ZmlsbCBhdCB0aGUgZ2l2ZW4gc2NvcGUuXG4gICAqIEEgc2NvcGUgaW4gdGhpcyBjYXNlIGlzIGVpdGhlciB0aGUgdG9wLWxldmVsIERvY3VtZW50IG9yIGEgU2hhZG93IFJvb3QuXG4gICAqXG4gICAqIEBwYXJhbSB7KERvY3VtZW50fFNoYWRvd1Jvb3QpfSBzY29wZVxuICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9XSUNHL2ZvY3VzLXZpc2libGVcbiAgICovXG4gIGZ1bmN0aW9uIGFwcGx5Rm9jdXNWaXNpYmxlUG9seWZpbGwoc2NvcGUpIHtcbiAgICB2YXIgaGFkS2V5Ym9hcmRFdmVudCA9IHRydWU7XG4gICAgdmFyIGhhZEZvY3VzVmlzaWJsZVJlY2VudGx5ID0gZmFsc2U7XG4gICAgdmFyIGhhZEZvY3VzVmlzaWJsZVJlY2VudGx5VGltZW91dCA9IG51bGw7XG5cbiAgICB2YXIgaW5wdXRUeXBlc0FsbG93bGlzdCA9IHtcbiAgICAgIHRleHQ6IHRydWUsXG4gICAgICBzZWFyY2g6IHRydWUsXG4gICAgICB1cmw6IHRydWUsXG4gICAgICB0ZWw6IHRydWUsXG4gICAgICBlbWFpbDogdHJ1ZSxcbiAgICAgIHBhc3N3b3JkOiB0cnVlLFxuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgZGF0ZTogdHJ1ZSxcbiAgICAgIG1vbnRoOiB0cnVlLFxuICAgICAgd2VlazogdHJ1ZSxcbiAgICAgIHRpbWU6IHRydWUsXG4gICAgICBkYXRldGltZTogdHJ1ZSxcbiAgICAgICdkYXRldGltZS1sb2NhbCc6IHRydWVcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIGZvciBsZWdhY3kgYnJvd3NlcnMgYW5kIGlmcmFtZXMgd2hpY2ggc29tZXRpbWVzIGZvY3VzXG4gICAgICogZWxlbWVudHMgbGlrZSBkb2N1bWVudCwgYm9keSwgYW5kIG5vbi1pbnRlcmFjdGl2ZSBTVkcuXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzVmFsaWRGb2N1c1RhcmdldChlbCkge1xuICAgICAgaWYgKFxuICAgICAgICBlbCAmJlxuICAgICAgICBlbCAhPT0gZG9jdW1lbnQgJiZcbiAgICAgICAgZWwubm9kZU5hbWUgIT09ICdIVE1MJyAmJlxuICAgICAgICBlbC5ub2RlTmFtZSAhPT0gJ0JPRFknICYmXG4gICAgICAgICdjbGFzc0xpc3QnIGluIGVsICYmXG4gICAgICAgICdjb250YWlucycgaW4gZWwuY2xhc3NMaXN0XG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgd2hldGhlciB0aGUgZ2l2ZW4gZWxlbWVudCBzaG91bGQgYXV0b21hdGljYWxseSB0cmlnZ2VyIHRoZVxuICAgICAqIGBmb2N1cy12aXNpYmxlYCBjbGFzcyBiZWluZyBhZGRlZCwgaS5lLiB3aGV0aGVyIGl0IHNob3VsZCBhbHdheXMgbWF0Y2hcbiAgICAgKiBgOmZvY3VzLXZpc2libGVgIHdoZW4gZm9jdXNlZC5cbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb2N1c1RyaWdnZXJzS2V5Ym9hcmRNb2RhbGl0eShlbCkge1xuICAgICAgdmFyIHR5cGUgPSBlbC50eXBlO1xuICAgICAgdmFyIHRhZ05hbWUgPSBlbC50YWdOYW1lO1xuXG4gICAgICBpZiAodGFnTmFtZSA9PT0gJ0lOUFVUJyAmJiBpbnB1dFR5cGVzQWxsb3dsaXN0W3R5cGVdICYmICFlbC5yZWFkT25seSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRhZ05hbWUgPT09ICdURVhUQVJFQScgJiYgIWVsLnJlYWRPbmx5KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWwuaXNDb250ZW50RWRpdGFibGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgdGhlIGBmb2N1cy12aXNpYmxlYCBjbGFzcyB0byB0aGUgZ2l2ZW4gZWxlbWVudCBpZiBpdCB3YXMgbm90IGFkZGVkIGJ5XG4gICAgICogdGhlIGF1dGhvci5cbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkRm9jdXNWaXNpYmxlQ2xhc3MoZWwpIHtcbiAgICAgIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMoJ2ZvY3VzLXZpc2libGUnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKCdmb2N1cy12aXNpYmxlJyk7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtZm9jdXMtdmlzaWJsZS1hZGRlZCcsICcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIGBmb2N1cy12aXNpYmxlYCBjbGFzcyBmcm9tIHRoZSBnaXZlbiBlbGVtZW50IGlmIGl0IHdhcyBub3RcbiAgICAgKiBvcmlnaW5hbGx5IGFkZGVkIGJ5IHRoZSBhdXRob3IuXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbW92ZUZvY3VzVmlzaWJsZUNsYXNzKGVsKSB7XG4gICAgICBpZiAoIWVsLmhhc0F0dHJpYnV0ZSgnZGF0YS1mb2N1cy12aXNpYmxlLWFkZGVkJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgnZm9jdXMtdmlzaWJsZScpO1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWZvY3VzLXZpc2libGUtYWRkZWQnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgbW9zdCByZWNlbnQgdXNlciBpbnRlcmFjdGlvbiB3YXMgdmlhIHRoZSBrZXlib2FyZDtcbiAgICAgKiBhbmQgdGhlIGtleSBwcmVzcyBkaWQgbm90IGluY2x1ZGUgYSBtZXRhLCBhbHQvb3B0aW9uLCBvciBjb250cm9sIGtleTtcbiAgICAgKiB0aGVuIHRoZSBtb2RhbGl0eSBpcyBrZXlib2FyZC4gT3RoZXJ3aXNlLCB0aGUgbW9kYWxpdHkgaXMgbm90IGtleWJvYXJkLlxuICAgICAqIEFwcGx5IGBmb2N1cy12aXNpYmxlYCB0byBhbnkgY3VycmVudCBhY3RpdmUgZWxlbWVudCBhbmQga2VlcCB0cmFja1xuICAgICAqIG9mIG91ciBrZXlib2FyZCBtb2RhbGl0eSBzdGF0ZSB3aXRoIGBoYWRLZXlib2FyZEV2ZW50YC5cbiAgICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbktleURvd24oZSkge1xuICAgICAgaWYgKGUubWV0YUtleSB8fCBlLmFsdEtleSB8fCBlLmN0cmxLZXkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNWYWxpZEZvY3VzVGFyZ2V0KHNjb3BlLmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgIGFkZEZvY3VzVmlzaWJsZUNsYXNzKHNjb3BlLmFjdGl2ZUVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBoYWRLZXlib2FyZEV2ZW50ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiBhdCBhbnkgcG9pbnQgYSB1c2VyIGNsaWNrcyB3aXRoIGEgcG9pbnRpbmcgZGV2aWNlLCBlbnN1cmUgdGhhdCB3ZSBjaGFuZ2VcbiAgICAgKiB0aGUgbW9kYWxpdHkgYXdheSBmcm9tIGtleWJvYXJkLlxuICAgICAqIFRoaXMgYXZvaWRzIHRoZSBzaXR1YXRpb24gd2hlcmUgYSB1c2VyIHByZXNzZXMgYSBrZXkgb24gYW4gYWxyZWFkeSBmb2N1c2VkXG4gICAgICogZWxlbWVudCwgYW5kIHRoZW4gY2xpY2tzIG9uIGEgZGlmZmVyZW50IGVsZW1lbnQsIGZvY3VzaW5nIGl0IHdpdGggYVxuICAgICAqIHBvaW50aW5nIGRldmljZSwgd2hpbGUgd2Ugc3RpbGwgdGhpbmsgd2UncmUgaW4ga2V5Ym9hcmQgbW9kYWxpdHkuXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uUG9pbnRlckRvd24oZSkge1xuICAgICAgaGFkS2V5Ym9hcmRFdmVudCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9uIGBmb2N1c2AsIGFkZCB0aGUgYGZvY3VzLXZpc2libGVgIGNsYXNzIHRvIHRoZSB0YXJnZXQgaWY6XG4gICAgICogLSB0aGUgdGFyZ2V0IHJlY2VpdmVkIGZvY3VzIGFzIGEgcmVzdWx0IG9mIGtleWJvYXJkIG5hdmlnYXRpb24sIG9yXG4gICAgICogLSB0aGUgZXZlbnQgdGFyZ2V0IGlzIGFuIGVsZW1lbnQgdGhhdCB3aWxsIGxpa2VseSByZXF1aXJlIGludGVyYWN0aW9uXG4gICAgICogICB2aWEgdGhlIGtleWJvYXJkIChlLmcuIGEgdGV4dCBib3gpXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uRm9jdXMoZSkge1xuICAgICAgLy8gUHJldmVudCBJRSBmcm9tIGZvY3VzaW5nIHRoZSBkb2N1bWVudCBvciBIVE1MIGVsZW1lbnQuXG4gICAgICBpZiAoIWlzVmFsaWRGb2N1c1RhcmdldChlLnRhcmdldCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGFkS2V5Ym9hcmRFdmVudCB8fCBmb2N1c1RyaWdnZXJzS2V5Ym9hcmRNb2RhbGl0eShlLnRhcmdldCkpIHtcbiAgICAgICAgYWRkRm9jdXNWaXNpYmxlQ2xhc3MoZS50YXJnZXQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9uIGBibHVyYCwgcmVtb3ZlIHRoZSBgZm9jdXMtdmlzaWJsZWAgY2xhc3MgZnJvbSB0aGUgdGFyZ2V0LlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbkJsdXIoZSkge1xuICAgICAgaWYgKCFpc1ZhbGlkRm9jdXNUYXJnZXQoZS50YXJnZXQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICBlLnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ2ZvY3VzLXZpc2libGUnKSB8fFxuICAgICAgICBlLnRhcmdldC5oYXNBdHRyaWJ1dGUoJ2RhdGEtZm9jdXMtdmlzaWJsZS1hZGRlZCcpXG4gICAgICApIHtcbiAgICAgICAgLy8gVG8gZGV0ZWN0IGEgdGFiL3dpbmRvdyBzd2l0Y2gsIHdlIGxvb2sgZm9yIGEgYmx1ciBldmVudCBmb2xsb3dlZFxuICAgICAgICAvLyByYXBpZGx5IGJ5IGEgdmlzaWJpbGl0eSBjaGFuZ2UuXG4gICAgICAgIC8vIElmIHdlIGRvbid0IHNlZSBhIHZpc2liaWxpdHkgY2hhbmdlIHdpdGhpbiAxMDBtcywgaXQncyBwcm9iYWJseSBhXG4gICAgICAgIC8vIHJlZ3VsYXIgZm9jdXMgY2hhbmdlLlxuICAgICAgICBoYWRGb2N1c1Zpc2libGVSZWNlbnRseSA9IHRydWU7XG4gICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoaGFkRm9jdXNWaXNpYmxlUmVjZW50bHlUaW1lb3V0KTtcbiAgICAgICAgaGFkRm9jdXNWaXNpYmxlUmVjZW50bHlUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaGFkRm9jdXNWaXNpYmxlUmVjZW50bHkgPSBmYWxzZTtcbiAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgcmVtb3ZlRm9jdXNWaXNpYmxlQ2xhc3MoZS50YXJnZXQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIHRoZSB1c2VyIGNoYW5nZXMgdGFicywga2VlcCB0cmFjayBvZiB3aGV0aGVyIG9yIG5vdCB0aGUgcHJldmlvdXNseVxuICAgICAqIGZvY3VzZWQgZWxlbWVudCBoYWQgLmZvY3VzLXZpc2libGUuXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uVmlzaWJpbGl0eUNoYW5nZShlKSB7XG4gICAgICBpZiAoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAnaGlkZGVuJykge1xuICAgICAgICAvLyBJZiB0aGUgdGFiIGJlY29tZXMgYWN0aXZlIGFnYWluLCB0aGUgYnJvd3NlciB3aWxsIGhhbmRsZSBjYWxsaW5nIGZvY3VzXG4gICAgICAgIC8vIG9uIHRoZSBlbGVtZW50IChTYWZhcmkgYWN0dWFsbHkgY2FsbHMgaXQgdHdpY2UpLlxuICAgICAgICAvLyBJZiB0aGlzIHRhYiBjaGFuZ2UgY2F1c2VkIGEgYmx1ciBvbiBhbiBlbGVtZW50IHdpdGggZm9jdXMtdmlzaWJsZSxcbiAgICAgICAgLy8gcmUtYXBwbHkgdGhlIGNsYXNzIHdoZW4gdGhlIHVzZXIgc3dpdGNoZXMgYmFjayB0byB0aGUgdGFiLlxuICAgICAgICBpZiAoaGFkRm9jdXNWaXNpYmxlUmVjZW50bHkpIHtcbiAgICAgICAgICBoYWRLZXlib2FyZEV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBhZGRJbml0aWFsUG9pbnRlck1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBncm91cCBvZiBsaXN0ZW5lcnMgdG8gZGV0ZWN0IHVzYWdlIG9mIGFueSBwb2ludGluZyBkZXZpY2VzLlxuICAgICAqIFRoZXNlIGxpc3RlbmVycyB3aWxsIGJlIGFkZGVkIHdoZW4gdGhlIHBvbHlmaWxsIGZpcnN0IGxvYWRzLCBhbmQgYW55dGltZVxuICAgICAqIHRoZSB3aW5kb3cgaXMgYmx1cnJlZCwgc28gdGhhdCB0aGV5IGFyZSBhY3RpdmUgd2hlbiB0aGUgd2luZG93IHJlZ2FpbnNcbiAgICAgKiBmb2N1cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZGRJbml0aWFsUG9pbnRlck1vdmVMaXN0ZW5lcnMoKSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbkluaXRpYWxQb2ludGVyTW92ZSk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBvbkluaXRpYWxQb2ludGVyTW92ZSk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Jbml0aWFsUG9pbnRlck1vdmUpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCBvbkluaXRpYWxQb2ludGVyTW92ZSk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIG9uSW5pdGlhbFBvaW50ZXJNb3ZlKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIG9uSW5pdGlhbFBvaW50ZXJNb3ZlKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uSW5pdGlhbFBvaW50ZXJNb3ZlKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBvbkluaXRpYWxQb2ludGVyTW92ZSk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uSW5pdGlhbFBvaW50ZXJNb3ZlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVJbml0aWFsUG9pbnRlck1vdmVMaXN0ZW5lcnMoKSB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbkluaXRpYWxQb2ludGVyTW92ZSk7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBvbkluaXRpYWxQb2ludGVyTW92ZSk7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Jbml0aWFsUG9pbnRlck1vdmUpO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCBvbkluaXRpYWxQb2ludGVyTW92ZSk7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIG9uSW5pdGlhbFBvaW50ZXJNb3ZlKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIG9uSW5pdGlhbFBvaW50ZXJNb3ZlKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uSW5pdGlhbFBvaW50ZXJNb3ZlKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBvbkluaXRpYWxQb2ludGVyTW92ZSk7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uSW5pdGlhbFBvaW50ZXJNb3ZlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZSBwb2xmeWlsbCBmaXJzdCBsb2FkcywgYXNzdW1lIHRoZSB1c2VyIGlzIGluIGtleWJvYXJkIG1vZGFsaXR5LlxuICAgICAqIElmIGFueSBldmVudCBpcyByZWNlaXZlZCBmcm9tIGEgcG9pbnRpbmcgZGV2aWNlIChlLmcuIG1vdXNlLCBwb2ludGVyLFxuICAgICAqIHRvdWNoKSwgdHVybiBvZmYga2V5Ym9hcmQgbW9kYWxpdHkuXG4gICAgICogVGhpcyBhY2NvdW50cyBmb3Igc2l0dWF0aW9ucyB3aGVyZSBmb2N1cyBlbnRlcnMgdGhlIHBhZ2UgZnJvbSB0aGUgVVJMIGJhci5cbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25Jbml0aWFsUG9pbnRlck1vdmUoZSkge1xuICAgICAgLy8gV29yayBhcm91bmQgYSBTYWZhcmkgcXVpcmsgdGhhdCBmaXJlcyBhIG1vdXNlbW92ZSBvbiA8aHRtbD4gd2hlbmV2ZXIgdGhlXG4gICAgICAvLyB3aW5kb3cgYmx1cnMsIGV2ZW4gaWYgeW91J3JlIHRhYmJpbmcgb3V0IG9mIHRoZSBwYWdlLiDCr1xcXyjjg4QpXy/Cr1xuICAgICAgaWYgKGUudGFyZ2V0Lm5vZGVOYW1lICYmIGUudGFyZ2V0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdodG1sJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGhhZEtleWJvYXJkRXZlbnQgPSBmYWxzZTtcbiAgICAgIHJlbW92ZUluaXRpYWxQb2ludGVyTW92ZUxpc3RlbmVycygpO1xuICAgIH1cblxuICAgIC8vIEZvciBzb21lIGtpbmRzIG9mIHN0YXRlLCB3ZSBhcmUgaW50ZXJlc3RlZCBpbiBjaGFuZ2VzIGF0IHRoZSBnbG9iYWwgc2NvcGVcbiAgICAvLyBvbmx5LiBGb3IgZXhhbXBsZSwgZ2xvYmFsIHBvaW50ZXIgaW5wdXQsIGdsb2JhbCBrZXkgcHJlc3NlcyBhbmQgZ2xvYmFsXG4gICAgLy8gdmlzaWJpbGl0eSBjaGFuZ2Ugc2hvdWxkIGFmZmVjdCB0aGUgc3RhdGUgYXQgZXZlcnkgc2NvcGU6XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIG9uS2V5RG93biwgdHJ1ZSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgb25Qb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCBvblBvaW50ZXJEb3duLCB0cnVlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgb25Qb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIG9uVmlzaWJpbGl0eUNoYW5nZSwgdHJ1ZSk7XG5cbiAgICBhZGRJbml0aWFsUG9pbnRlck1vdmVMaXN0ZW5lcnMoKTtcblxuICAgIC8vIEZvciBmb2N1cyBhbmQgYmx1ciwgd2Ugc3BlY2lmaWNhbGx5IGNhcmUgYWJvdXQgc3RhdGUgY2hhbmdlcyBpbiB0aGUgbG9jYWxcbiAgICAvLyBzY29wZS4gVGhpcyBpcyBiZWNhdXNlIGZvY3VzIC8gYmx1ciBldmVudHMgdGhhdCBvcmlnaW5hdGUgZnJvbSB3aXRoaW4gYVxuICAgIC8vIHNoYWRvdyByb290IGFyZSBub3QgcmUtZGlzcGF0Y2hlZCBmcm9tIHRoZSBob3N0IGVsZW1lbnQgaWYgaXQgd2FzIGFscmVhZHlcbiAgICAvLyB0aGUgYWN0aXZlIGVsZW1lbnQgaW4gaXRzIG93biBzY29wZTpcbiAgICBzY29wZS5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIG9uRm9jdXMsIHRydWUpO1xuICAgIHNjb3BlLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBvbkJsdXIsIHRydWUpO1xuXG4gICAgLy8gV2UgZGV0ZWN0IHRoYXQgYSBub2RlIGlzIGEgU2hhZG93Um9vdCBieSBlbnN1cmluZyB0aGF0IGl0IGlzIGFcbiAgICAvLyBEb2N1bWVudEZyYWdtZW50IGFuZCBhbHNvIGhhcyBhIGhvc3QgcHJvcGVydHkuIFRoaXMgY2hlY2sgY292ZXJzIG5hdGl2ZVxuICAgIC8vIGltcGxlbWVudGF0aW9uIGFuZCBwb2x5ZmlsbCBpbXBsZW1lbnRhdGlvbiB0cmFuc3BhcmVudGx5LiBJZiB3ZSBvbmx5IGNhcmVkXG4gICAgLy8gYWJvdXQgdGhlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiwgd2UgY291bGQganVzdCBjaGVjayBpZiB0aGUgc2NvcGUgd2FzXG4gICAgLy8gYW4gaW5zdGFuY2Ugb2YgYSBTaGFkb3dSb290LlxuICAgIGlmIChzY29wZS5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFICYmIHNjb3BlLmhvc3QpIHtcbiAgICAgIC8vIFNpbmNlIGEgU2hhZG93Um9vdCBpcyBhIHNwZWNpYWwga2luZCBvZiBEb2N1bWVudEZyYWdtZW50LCBpdCBkb2VzIG5vdFxuICAgICAgLy8gaGF2ZSBhIHJvb3QgZWxlbWVudCB0byBhZGQgYSBjbGFzcyB0by4gU28sIHdlIGFkZCB0aGlzIGF0dHJpYnV0ZSB0byB0aGVcbiAgICAgIC8vIGhvc3QgZWxlbWVudCBpbnN0ZWFkOlxuICAgICAgc2NvcGUuaG9zdC5zZXRBdHRyaWJ1dGUoJ2RhdGEtanMtZm9jdXMtdmlzaWJsZScsICcnKTtcbiAgICB9IGVsc2UgaWYgKHNjb3BlLm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX05PREUpIHtcbiAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGFzc0xpc3QuYWRkKCdqcy1mb2N1cy12aXNpYmxlJyk7XG4gICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLWpzLWZvY3VzLXZpc2libGUnLCAnJyk7XG4gICAgfVxuICB9XG5cbiAgLy8gSXQgaXMgaW1wb3J0YW50IHRvIHdyYXAgYWxsIHJlZmVyZW5jZXMgdG8gZ2xvYmFsIHdpbmRvdyBhbmQgZG9jdW1lbnQgaW5cbiAgLy8gdGhlc2UgY2hlY2tzIHRvIHN1cHBvcnQgc2VydmVyLXNpZGUgcmVuZGVyaW5nIHVzZSBjYXNlc1xuICAvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9XSUNHL2ZvY3VzLXZpc2libGUvaXNzdWVzLzE5OVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIE1ha2UgdGhlIHBvbHlmaWxsIGhlbHBlciBnbG9iYWxseSBhdmFpbGFibGUuIFRoaXMgY2FuIGJlIHVzZWQgYXMgYSBzaWduYWxcbiAgICAvLyB0byBpbnRlcmVzdGVkIGxpYnJhcmllcyB0aGF0IHdpc2ggdG8gY29vcmRpbmF0ZSB3aXRoIHRoZSBwb2x5ZmlsbCBmb3IgZS5nLixcbiAgICAvLyBhcHBseWluZyB0aGUgcG9seWZpbGwgdG8gYSBzaGFkb3cgcm9vdDpcbiAgICB3aW5kb3cuYXBwbHlGb2N1c1Zpc2libGVQb2x5ZmlsbCA9IGFwcGx5Rm9jdXNWaXNpYmxlUG9seWZpbGw7XG5cbiAgICAvLyBOb3RpZnkgaW50ZXJlc3RlZCBsaWJyYXJpZXMgb2YgdGhlIHBvbHlmaWxsJ3MgcHJlc2VuY2UsIGluIGNhc2UgdGhlXG4gICAgLy8gcG9seWZpbGwgd2FzIGxvYWRlZCBsYXppbHk6XG4gICAgdmFyIGV2ZW50O1xuXG4gICAgdHJ5IHtcbiAgICAgIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdmb2N1cy12aXNpYmxlLXBvbHlmaWxsLXJlYWR5Jyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIElFMTEgZG9lcyBub3Qgc3VwcG9ydCB1c2luZyBDdXN0b21FdmVudCBhcyBhIGNvbnN0cnVjdG9yIGRpcmVjdGx5OlxuICAgICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICAgIGV2ZW50LmluaXRDdXN0b21FdmVudCgnZm9jdXMtdmlzaWJsZS1wb2x5ZmlsbC1yZWFkeScsIGZhbHNlLCBmYWxzZSwge30pO1xuICAgIH1cblxuICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gQXBwbHkgdGhlIHBvbHlmaWxsIHRvIHRoZSBnbG9iYWwgZG9jdW1lbnQsIHNvIHRoYXQgbm8gSmF2YVNjcmlwdFxuICAgIC8vIGNvb3JkaW5hdGlvbiBpcyByZXF1aXJlZCB0byB1c2UgdGhlIHBvbHlmaWxsIGluIHRoZSB0b3AtbGV2ZWwgZG9jdW1lbnQ6XG4gICAgYXBwbHlGb2N1c1Zpc2libGVQb2x5ZmlsbChkb2N1bWVudCk7XG4gIH1cblxufSkpKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3c7622ff\n");

/***/ }),

/***/ "7d23ec59":
/*!*******************************************************!*\
  !*** ./node_modules/n-ui-foundations/js/perf-mark.js ***!
  \*******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

eval("module.exports = name => {\n  const performance = window.LUX || window.performance || window.msPerformance || window.webkitPerformance || window.mozPerformance;\n  if (performance && performance.mark) {\n    performance.mark(name);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiN2QyM2VjNTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbi11aS1mb3VuZGF0aW9ucy9qcy9wZXJmLW1hcmsuanM/MGYyYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IG5hbWUgPT4ge1xuXHRjb25zdCBwZXJmb3JtYW5jZSA9IHdpbmRvdy5MVVggfHwgd2luZG93LnBlcmZvcm1hbmNlIHx8IHdpbmRvdy5tc1BlcmZvcm1hbmNlIHx8IHdpbmRvdy53ZWJraXRQZXJmb3JtYW5jZSB8fCB3aW5kb3cubW96UGVyZm9ybWFuY2U7XG5cdGlmIChwZXJmb3JtYW5jZSAmJiBwZXJmb3JtYW5jZS5tYXJrKSB7XG5cdFx0cGVyZm9ybWFuY2UubWFyayhuYW1lKTtcblx0fVxufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7d23ec59\n");

/***/ }),

/***/ "8b3ea372":
/*!******************************************************!*\
  !*** ./node_modules/n-ui-foundations/js/to-ascii.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

eval("const mapASCII = {\n  'à': 'a',\n  'á': 'a',\n  'â': 'a',\n  'ä': 'a',\n  'ã': 'a',\n  'å': 'a',\n  'ā': 'a',\n  'æ': 'ae',\n  'ç': 'c',\n  'č': 'c',\n  'è': 'e',\n  'é': 'e',\n  'ê': 'e',\n  'ë': 'e',\n  'ē': 'e',\n  'ğ': 'g',\n  'î': 'i',\n  'ï': 'i',\n  'í': 'i',\n  'ì': 'i',\n  'ī': 'i',\n  'ł': 'l',\n  'ñ': 'n',\n  'ń': 'n',\n  'ô': 'o',\n  'ö': 'o',\n  'ò': 'o',\n  'ó': 'o',\n  'ø': 'o',\n  'õ': 'o',\n  'ō': 'o',\n  'œ': 'oe',\n  'ş': 's',\n  'ș': 's',\n  'š': 's',\n  'ß': 'ss',\n  'û': 'u',\n  'ü': 'u',\n  'ù': 'u',\n  'ú': 'u',\n  'ū': 'u',\n  'ž': 'z'\n};\nconst nonASCII = /[^\\x00-\\x7F]+/;\nfunction toASCII(string) {\n  if (nonASCII.test(string) === false) {\n    return string;\n  }\n  let i = string.length;\n  while (i > -1) {\n    const ascii = mapASCII[string[i]];\n    if (ascii) {\n      string = string.substr(0, i) + ascii + string.substr(i + 1);\n    }\n    i--;\n  }\n  return string;\n}\nmodule.exports = toASCII;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOGIzZWEzNzIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbi11aS1mb3VuZGF0aW9ucy9qcy90by1hc2NpaS5qcz84NjgwIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IG1hcEFTQ0lJID0ge1xuXHQnw6AnOiAnYScsXG5cdCfDoSc6ICdhJyxcblx0J8OiJzogJ2EnLFxuXHQnw6QnOiAnYScsXG5cdCfDoyc6ICdhJyxcblx0J8OlJzogJ2EnLFxuXHQnxIEnOiAnYScsXG5cdCfDpic6ICdhZScsXG5cdCfDpyc6ICdjJyxcblx0J8SNJzogJ2MnLFxuXHQnw6gnOiAnZScsXG5cdCfDqSc6ICdlJyxcblx0J8OqJzogJ2UnLFxuXHQnw6snOiAnZScsXG5cdCfEkyc6ICdlJyxcblx0J8SfJzogJ2cnLFxuXHQnw64nOiAnaScsXG5cdCfDryc6ICdpJyxcblx0J8OtJzogJ2knLFxuXHQnw6wnOiAnaScsXG5cdCfEqyc6ICdpJyxcblx0J8WCJzogJ2wnLFxuXHQnw7EnOiAnbicsXG5cdCfFhCc6ICduJyxcblx0J8O0JzogJ28nLFxuXHQnw7YnOiAnbycsXG5cdCfDsic6ICdvJyxcblx0J8OzJzogJ28nLFxuXHQnw7gnOiAnbycsXG5cdCfDtSc6ICdvJyxcblx0J8WNJzogJ28nLFxuXHQnxZMnOiAnb2UnLFxuXHQnxZ8nOiAncycsXG5cdCfImSc6ICdzJyxcblx0J8WhJzogJ3MnLFxuXHQnw58nOiAnc3MnLFxuXHQnw7snOiAndScsXG5cdCfDvCc6ICd1Jyxcblx0J8O5JzogJ3UnLFxuXHQnw7onOiAndScsXG5cdCfFqyc6ICd1Jyxcblx0J8W+JzogJ3onXG59O1xuXG5jb25zdCBub25BU0NJSSA9IC9bXlxceDAwLVxceDdGXSsvO1xuXG5mdW5jdGlvbiB0b0FTQ0lJIChzdHJpbmcpIHtcblx0aWYgKG5vbkFTQ0lJLnRlc3Qoc3RyaW5nKSA9PT0gZmFsc2UpIHtcblx0XHRyZXR1cm4gc3RyaW5nO1xuXHR9XG5cblx0bGV0IGkgPSBzdHJpbmcubGVuZ3RoO1xuXG5cdHdoaWxlIChpID4gLTEpIHtcblx0XHRjb25zdCBhc2NpaSA9IG1hcEFTQ0lJW3N0cmluZ1tpXV07XG5cblx0XHRpZiAoYXNjaWkpIHtcblx0XHRcdHN0cmluZyA9IHN0cmluZy5zdWJzdHIoMCwgaSkgKyBhc2NpaSArIHN0cmluZy5zdWJzdHIoaSArIDEpO1xuXHRcdH1cblxuXHRcdGktLTtcblx0fVxuXG5cdHJldHVybiBzdHJpbmc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9BU0NJSTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8b3ea372\n");

/***/ }),

/***/ "ae05e6f9":
/*!*****************************************************!*\
  !*** ./node_modules/n-ui-foundations/js/cookies.js ***!
  \*****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

eval("//TODO we may want to replace this with https://github.com/WICG/async-cookies-api at some point in the future\n\n// Regex taken from https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie don't ask me how it works\nfunction getRegexForName(name) {\n  return new RegExp(`(?:(?:^|.*;\\\\s*)${name}\\\\s*\\=\\\\s*([^;]*).*$)|^.*$`);\n}\nfunction getOptions(options) {\n  return Object.keys(options).map(key => {\n    let newKey = key;\n    if (key === 'maxAge') {\n      newKey = 'max-age';\n    }\n    if (options[key] instanceof Date) {\n      options[key] = options[key].toUTCString();\n    }\n    return `${newKey}=${options[key]}`;\n  });\n}\nfunction set(name, value) {\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const options = getOptions(opts).join('; ');\n  const cookie = `${encodeURIComponent(name)}=${encodeURIComponent(value)}; ${options}`;\n  document.cookie = cookie;\n}\nfunction get(name) {\n  return decodeURIComponent(document.cookie.replace(getRegexForName(encodeURIComponent(name)), '$1'));\n}\nfunction has(name) {\n  return new RegExp(encodeURIComponent(name) + '=').test(document.cookie);\n}\nfunction remove(name) {\n  return set(name, '', {\n    expires: new Date(0)\n  });\n}\nmodule.exports = {\n  get,\n  set,\n  has,\n  getRegexForName,\n  remove\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWUwNWU2ZjkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbi11aS1mb3VuZGF0aW9ucy9qcy9jb29raWVzLmpzP2M1YzYiXSwic291cmNlc0NvbnRlbnQiOlsiLy9UT0RPIHdlIG1heSB3YW50IHRvIHJlcGxhY2UgdGhpcyB3aXRoIGh0dHBzOi8vZ2l0aHViLmNvbS9XSUNHL2FzeW5jLWNvb2tpZXMtYXBpIGF0IHNvbWUgcG9pbnQgaW4gdGhlIGZ1dHVyZVxuXG4vLyBSZWdleCB0YWtlbiBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Eb2N1bWVudC9jb29raWUgZG9uJ3QgYXNrIG1lIGhvdyBpdCB3b3Jrc1xuZnVuY3Rpb24gZ2V0UmVnZXhGb3JOYW1lIChuYW1lKXtcblx0cmV0dXJuIG5ldyBSZWdFeHAoYCg/Oig/Ol58Lio7XFxcXHMqKSR7bmFtZX1cXFxccypcXD1cXFxccyooW147XSopLiokKXxeLiokYCk7XG59XG5cbmZ1bmN0aW9uIGdldE9wdGlvbnMgKG9wdGlvbnMpe1xuXHRyZXR1cm4gT2JqZWN0LmtleXMob3B0aW9ucykubWFwKGtleSA9PiB7XG5cdFx0bGV0IG5ld0tleSA9IGtleTtcblx0XHRpZihrZXkgPT09ICdtYXhBZ2UnKXtcblx0XHRcdG5ld0tleSA9ICdtYXgtYWdlJztcblx0XHR9XG5cblx0XHRpZihvcHRpb25zW2tleV0gaW5zdGFuY2VvZiBEYXRlKXtcblx0XHRcdG9wdGlvbnNba2V5XSA9IG9wdGlvbnNba2V5XS50b1VUQ1N0cmluZygpO1xuXHRcdH1cblxuXHRcdHJldHVybiBgJHtuZXdLZXl9PSR7b3B0aW9uc1trZXldfWA7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBzZXQgKG5hbWUsIHZhbHVlLCBvcHRzID0ge30pe1xuXHRjb25zdCBvcHRpb25zID0gZ2V0T3B0aW9ucyhvcHRzKS5qb2luKCc7ICcpO1xuXHRjb25zdCBjb29raWUgPSBgJHtlbmNvZGVVUklDb21wb25lbnQobmFtZSl9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKX07ICR7b3B0aW9uc31gO1xuXHRkb2N1bWVudC5jb29raWUgPSBjb29raWU7XG59XG5cbmZ1bmN0aW9uIGdldCAobmFtZSl7XG5cdHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZG9jdW1lbnQuY29va2llLnJlcGxhY2UoZ2V0UmVnZXhGb3JOYW1lKGVuY29kZVVSSUNvbXBvbmVudChuYW1lKSksICckMScpKTtcbn1cblxuZnVuY3Rpb24gaGFzIChuYW1lKXtcblx0cmV0dXJuIG5ldyBSZWdFeHAoZW5jb2RlVVJJQ29tcG9uZW50KG5hbWUpICsgJz0nKS50ZXN0KGRvY3VtZW50LmNvb2tpZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSAobmFtZSl7XG5cdHJldHVybiBzZXQobmFtZSwgJycsIHtleHBpcmVzOm5ldyBEYXRlKDApfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge2dldCwgc2V0LCBoYXMsIGdldFJlZ2V4Rm9yTmFtZSwgcmVtb3ZlfTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///ae05e6f9\n");

/***/ }),

/***/ "ae50df7e":
/*!********************************************************************!*\
  !*** ./node_modules/n-topic-search/src/renderers/base-renderer.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return BaseRenderer; });\n/* harmony import */ var morphdom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! morphdom */ \"f5ad1795\");\n\nfunction regExpEscape(s) {\n  return s.replace(/[-\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n}\nclass BaseRenderer {\n  constructor(container, options) {\n    this.container = container;\n    // ensure there is a dom node that morphdom can act on\n    this.container.appendChild(document.createElement('div'));\n    this.options = options;\n    this.state = {\n      suggestions: options.categories.reduce((containers, name) => {\n        containers[name] = [];\n        return containers;\n      }, {})\n    };\n  }\n  setState(state) {\n    this.state = state;\n    this.createHtml();\n    this.render();\n  }\n  highlight(text) {\n    return text.replace(RegExp(regExpEscape(this.state.searchTerm), 'gi'), '<mark>$&</mark>');\n  }\n  render() {\n    if (this.container.innerHTML.trim()) {\n      // empty the suggestions div first to prevent\n      // screen readers reading the old suggestions\n      const empty = document.createElement('div');\n      const suggestions = this.container.querySelector('.n-topic-search__suggestions');\n      if (suggestions) {\n        Object(morphdom__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(suggestions, empty);\n      }\n      const frag = document.createDocumentFragment();\n      frag.appendChild(document.createElement('div'));\n      frag.firstChild.insertAdjacentHTML('beforeend', this.newHtml);\n      Object(morphdom__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.container.firstChild, frag.firstChild);\n    } else {\n      this.container.innerHTML = this.newHtml;\n    }\n    this.newHtml = '';\n  }\n}\n;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWU1MGRmN2UuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbi10b3BpYy1zZWFyY2gvc3JjL3JlbmRlcmVycy9iYXNlLXJlbmRlcmVyLmpzPzRmMDIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG1vcnBoZG9tIGZyb20gJ21vcnBoZG9tJztcblxuZnVuY3Rpb24gcmVnRXhwRXNjYXBlIChzKSB7XG5cdHJldHVybiBzLnJlcGxhY2UoL1stXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNlUmVuZGVyZXIge1xuXHRjb25zdHJ1Y3RvciAoY29udGFpbmVyLCBvcHRpb25zKSB7XG5cdFx0dGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG5cdFx0Ly8gZW5zdXJlIHRoZXJlIGlzIGEgZG9tIG5vZGUgdGhhdCBtb3JwaGRvbSBjYW4gYWN0IG9uXG5cdFx0dGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpO1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cblx0XHR0aGlzLnN0YXRlID0ge1xuXHRcdFx0c3VnZ2VzdGlvbnM6IG9wdGlvbnMuY2F0ZWdvcmllcy5yZWR1Y2UoKGNvbnRhaW5lcnMsIG5hbWUpID0+IHtcblx0XHRcdFx0Y29udGFpbmVyc1tuYW1lXSA9IFtdO1xuXHRcdFx0XHRyZXR1cm4gY29udGFpbmVycztcblx0XHRcdH0sIHt9KVxuXHRcdH07XG5cdH1cblxuXHRzZXRTdGF0ZSAoc3RhdGUpIHtcblx0XHR0aGlzLnN0YXRlID0gc3RhdGU7XG5cdFx0dGhpcy5jcmVhdGVIdG1sKCk7XG5cdFx0dGhpcy5yZW5kZXIoKTtcblx0fVxuXG5cdGhpZ2hsaWdodCAodGV4dCkge1xuXHRcdHJldHVybiB0ZXh0LnJlcGxhY2UoUmVnRXhwKHJlZ0V4cEVzY2FwZSh0aGlzLnN0YXRlLnNlYXJjaFRlcm0pLCAnZ2knKSwgJzxtYXJrPiQmPC9tYXJrPicpO1xuXHR9XG5cblx0cmVuZGVyICgpIHtcblx0XHRpZiAodGhpcy5jb250YWluZXIuaW5uZXJIVE1MLnRyaW0oKSkge1xuXHRcdFx0Ly8gZW1wdHkgdGhlIHN1Z2dlc3Rpb25zIGRpdiBmaXJzdCB0byBwcmV2ZW50XG5cdFx0XHQvLyBzY3JlZW4gcmVhZGVycyByZWFkaW5nIHRoZSBvbGQgc3VnZ2VzdGlvbnNcblx0XHRcdGNvbnN0IGVtcHR5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0XHRjb25zdCBzdWdnZXN0aW9ucyA9IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5uLXRvcGljLXNlYXJjaF9fc3VnZ2VzdGlvbnMnKTtcblx0XHRcdGlmIChzdWdnZXN0aW9ucykge1xuXHRcdFx0XHRtb3JwaGRvbShzdWdnZXN0aW9ucywgZW1wdHkpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdFx0ZnJhZy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSk7XG5cdFx0XHRmcmFnLmZpcnN0Q2hpbGQuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLCB0aGlzLm5ld0h0bWwpO1xuXG5cdFx0XHRtb3JwaGRvbSh0aGlzLmNvbnRhaW5lci5maXJzdENoaWxkLCBmcmFnLmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmNvbnRhaW5lci5pbm5lckhUTUwgPSB0aGlzLm5ld0h0bWw7XG5cdFx0fVxuXHRcdHRoaXMubmV3SHRtbCA9ICcnO1xuXHR9XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///ae50df7e\n");

/***/ }),

/***/ "b4722769":
/*!*********************************************************!*\
  !*** ./node_modules/ready-state/dist/ready-state.es.js ***!
  \*********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loading\", function() { return r; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"interactive\", function() { return o; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"complete\", function() { return u; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"domready\", function() { return i; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"load\", function() { return c; });\nvar e = {\n    capture: !0,\n    once: !0,\n    passive: !0\n  },\n  t = function () {\n    return \"interactive\" === document.readyState || \"complete\" === document.readyState;\n  },\n  n = function (e, n) {\n    return !(!function (e) {\n      return document.readyState === e;\n    }(e) && !t()) && (n(e), !0);\n  },\n  r = function () {\n    return new Promise(function (t) {\n      n(\"loading\", t) || document.addEventListener(\"readystatechange\", function () {\n        \"loading\" === document.readyState && t(\"loading\");\n      }, e);\n    });\n  },\n  o = function () {\n    return new Promise(function (t) {\n      n(\"interactive\", t) || document.addEventListener(\"readystatechange\", function () {\n        \"interactive\" === document.readyState && t(\"interactive\");\n      }, e);\n    });\n  },\n  u = function () {\n    return new Promise(function (t) {\n      n(\"complete\", t) || document.addEventListener(\"readystatechange\", function () {\n        \"complete\" === document.readyState && t(\"complete\");\n      }, e);\n    });\n  },\n  i = function () {\n    return new Promise(function (t) {\n      n(\"domready\", t) || document.addEventListener(\"DOMContentLoaded\", function () {\n        t(\"domready\");\n      }, e);\n    });\n  },\n  c = function () {\n    return new Promise(function (t) {\n      n(\"load\", t) || window.addEventListener(\"load\", function () {\n        t(\"load\");\n      }, e);\n    });\n  },\n  d = {};\nObject.defineProperties(d, {\n  state: {\n    get: function () {\n      return document.readyState;\n    }\n  },\n  loading: {\n    get: function () {\n      return r();\n    }\n  },\n  interactive: {\n    get: function () {\n      return o();\n    }\n  },\n  complete: {\n    get: function () {\n      return u();\n    }\n  },\n  window: {\n    get: function () {\n      return c();\n    }\n  },\n  load: {\n    get: function () {\n      return c();\n    }\n  },\n  domready: {\n    get: function () {\n      return i();\n    }\n  },\n  dom: {\n    get: function () {\n      return i();\n    }\n  },\n  ready: {\n    get: function () {\n      return t();\n    }\n  }\n});\n/* harmony default export */ __webpack_exports__[\"default\"] = (d);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYjQ3MjI3NjkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZHktc3RhdGUvZGlzdC9yZWFkeS1zdGF0ZS5lcy5qcz8yMGQ2Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBlPXtjYXB0dXJlOiEwLG9uY2U6ITAscGFzc2l2ZTohMH0sdD1mdW5jdGlvbigpe3JldHVyblwiaW50ZXJhY3RpdmVcIj09PWRvY3VtZW50LnJlYWR5U3RhdGV8fFwiY29tcGxldGVcIj09PWRvY3VtZW50LnJlYWR5U3RhdGV9LG49ZnVuY3Rpb24oZSxuKXtyZXR1cm4hKCFmdW5jdGlvbihlKXtyZXR1cm4gZG9jdW1lbnQucmVhZHlTdGF0ZT09PWV9KGUpJiYhdCgpKSYmKG4oZSksITApfSxyPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHQpe24oXCJsb2FkaW5nXCIsdCl8fGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZWFkeXN0YXRlY2hhbmdlXCIsZnVuY3Rpb24oKXtcImxvYWRpbmdcIj09PWRvY3VtZW50LnJlYWR5U3RhdGUmJnQoXCJsb2FkaW5nXCIpfSxlKX0pfSxvPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHQpe24oXCJpbnRlcmFjdGl2ZVwiLHQpfHxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwicmVhZHlzdGF0ZWNoYW5nZVwiLGZ1bmN0aW9uKCl7XCJpbnRlcmFjdGl2ZVwiPT09ZG9jdW1lbnQucmVhZHlTdGF0ZSYmdChcImludGVyYWN0aXZlXCIpfSxlKX0pfSx1PWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHQpe24oXCJjb21wbGV0ZVwiLHQpfHxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwicmVhZHlzdGF0ZWNoYW5nZVwiLGZ1bmN0aW9uKCl7XCJjb21wbGV0ZVwiPT09ZG9jdW1lbnQucmVhZHlTdGF0ZSYmdChcImNvbXBsZXRlXCIpfSxlKX0pfSxpPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHQpe24oXCJkb21yZWFkeVwiLHQpfHxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLGZ1bmN0aW9uKCl7dChcImRvbXJlYWR5XCIpfSxlKX0pfSxjPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHQpe24oXCJsb2FkXCIsdCl8fHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLGZ1bmN0aW9uKCl7dChcImxvYWRcIil9LGUpfSl9LGQ9e307T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZCx7c3RhdGU6e2dldDpmdW5jdGlvbigpe3JldHVybiBkb2N1bWVudC5yZWFkeVN0YXRlfX0sbG9hZGluZzp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHIoKX19LGludGVyYWN0aXZlOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbygpfX0sY29tcGxldGU6e2dldDpmdW5jdGlvbigpe3JldHVybiB1KCl9fSx3aW5kb3c6e2dldDpmdW5jdGlvbigpe3JldHVybiBjKCl9fSxsb2FkOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYygpfX0sZG9tcmVhZHk6e2dldDpmdW5jdGlvbigpe3JldHVybiBpKCl9fSxkb206e2dldDpmdW5jdGlvbigpe3JldHVybiBpKCl9fSxyZWFkeTp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHQoKX19fSk7ZXhwb3J0IGRlZmF1bHQgZDtleHBvcnR7ciBhcyBsb2FkaW5nLG8gYXMgaW50ZXJhY3RpdmUsdSBhcyBjb21wbGV0ZSxpIGFzIGRvbXJlYWR5LGMgYXMgbG9hZH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFkeS1zdGF0ZS5lcy5qcy5tYXBcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///b4722769\n");

/***/ }),

/***/ "e6b19cd3":
/*!********************************************!*\
  !*** ./node_modules/ftdomdelegate/main.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\n * DOM event delegator\n *\n * The delegator will listen\n * for events that bubble up\n * to the root node.\n *\n * @constructor\n * @param {Node|string} [root] The root node or a selector string matching the root node\n */\nfunction Delegate(root) {\n  /**\n   * Maintain a map of listener\n   * lists, keyed by event name.\n   *\n   * @type Object\n   */\n  this.listenerMap = [{}, {}];\n  if (root) {\n    this.root(root);\n  }\n\n  /** @type function() */\n  this.handle = Delegate.prototype.handle.bind(this);\n\n  // Cache of event listeners removed during an event cycle\n  this._removedListeners = [];\n}\n\n/**\n * Start listening for events\n * on the provided DOM element\n *\n * @param  {Node|string} [root] The root node or a selector string matching the root node\n * @returns {Delegate} This method is chainable\n */\nDelegate.prototype.root = function (root) {\n  const listenerMap = this.listenerMap;\n  let eventType;\n\n  // Remove master event listeners\n  if (this.rootElement) {\n    for (eventType in listenerMap[1]) {\n      if (listenerMap[1].hasOwnProperty(eventType)) {\n        this.rootElement.removeEventListener(eventType, this.handle, true);\n      }\n    }\n    for (eventType in listenerMap[0]) {\n      if (listenerMap[0].hasOwnProperty(eventType)) {\n        this.rootElement.removeEventListener(eventType, this.handle, false);\n      }\n    }\n  }\n\n  // If no root or root is not\n  // a dom node, then remove internal\n  // root reference and exit here\n  if (!root || !root.addEventListener) {\n    if (this.rootElement) {\n      delete this.rootElement;\n    }\n    return this;\n  }\n\n  /**\n   * The root node at which\n   * listeners are attached.\n   *\n   * @type Node\n   */\n  this.rootElement = root;\n\n  // Set up master event listeners\n  for (eventType in listenerMap[1]) {\n    if (listenerMap[1].hasOwnProperty(eventType)) {\n      this.rootElement.addEventListener(eventType, this.handle, true);\n    }\n  }\n  for (eventType in listenerMap[0]) {\n    if (listenerMap[0].hasOwnProperty(eventType)) {\n      this.rootElement.addEventListener(eventType, this.handle, false);\n    }\n  }\n  return this;\n};\n\n/**\n * @param {string} eventType\n * @returns boolean\n */\nDelegate.prototype.captureForType = function (eventType) {\n  return ['blur', 'error', 'focus', 'load', 'resize', 'scroll'].indexOf(eventType) !== -1;\n};\n\n/**\n * Attach a handler to one\n * event for all elements\n * that match the selector,\n * now or in the future\n *\n * The handler function receives\n * three arguments: the DOM event\n * object, the node that matched\n * the selector while the event\n * was bubbling and a reference\n * to itself. Within the handler,\n * 'this' is equal to the second\n * argument.\n *\n * The node that actually received\n * the event can be accessed via\n * 'event.target'.\n *\n * @param {string} eventType Listen for these events\n * @param {string|undefined} selector Only handle events on elements matching this selector, if undefined match root element\n * @param {function()} handler Handler function - event data passed here will be in event.data\n * @param {boolean} [useCapture] see 'useCapture' in <https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener>\n * @returns {Delegate} This method is chainable\n */\nDelegate.prototype.on = function (eventType, selector, handler, useCapture) {\n  let root;\n  let listenerMap;\n  let matcher;\n  let matcherParam;\n  if (!eventType) {\n    throw new TypeError('Invalid event type: ' + eventType);\n  }\n\n  // handler can be passed as\n  // the second or third argument\n  if (typeof selector === 'function') {\n    useCapture = handler;\n    handler = selector;\n    selector = null;\n  }\n\n  // Fallback to sensible defaults\n  // if useCapture not set\n  if (useCapture === undefined) {\n    useCapture = this.captureForType(eventType);\n  }\n  if (typeof handler !== 'function') {\n    throw new TypeError('Handler must be a type of Function');\n  }\n  root = this.rootElement;\n  listenerMap = this.listenerMap[useCapture ? 1 : 0];\n\n  // Add master handler for type if not created yet\n  if (!listenerMap[eventType]) {\n    if (root) {\n      root.addEventListener(eventType, this.handle, useCapture);\n    }\n    listenerMap[eventType] = [];\n  }\n  if (!selector) {\n    matcherParam = null;\n\n    // COMPLEX - matchesRoot needs to have access to\n    // this.rootElement, so bind the function to this.\n    matcher = matchesRoot.bind(this);\n\n    // Compile a matcher for the given selector\n  } else if (/^[a-z]+$/i.test(selector)) {\n    matcherParam = selector;\n    matcher = matchesTag;\n  } else if (/^#[a-z0-9\\-_]+$/i.test(selector)) {\n    matcherParam = selector.slice(1);\n    matcher = matchesId;\n  } else {\n    matcherParam = selector;\n    matcher = Element.prototype.matches;\n  }\n\n  // Add to the list of listeners\n  listenerMap[eventType].push({\n    selector: selector,\n    handler: handler,\n    matcher: matcher,\n    matcherParam: matcherParam\n  });\n  return this;\n};\n\n/**\n * Remove an event handler\n * for elements that match\n * the selector, forever\n *\n * @param {string} [eventType] Remove handlers for events matching this type, considering the other parameters\n * @param {string} [selector] If this parameter is omitted, only handlers which match the other two will be removed\n * @param {function()} [handler] If this parameter is omitted, only handlers which match the previous two will be removed\n * @returns {Delegate} This method is chainable\n */\nDelegate.prototype.off = function (eventType, selector, handler, useCapture) {\n  let i;\n  let listener;\n  let listenerMap;\n  let listenerList;\n  let singleEventType;\n\n  // Handler can be passed as\n  // the second or third argument\n  if (typeof selector === 'function') {\n    useCapture = handler;\n    handler = selector;\n    selector = null;\n  }\n\n  // If useCapture not set, remove\n  // all event listeners\n  if (useCapture === undefined) {\n    this.off(eventType, selector, handler, true);\n    this.off(eventType, selector, handler, false);\n    return this;\n  }\n  listenerMap = this.listenerMap[useCapture ? 1 : 0];\n  if (!eventType) {\n    for (singleEventType in listenerMap) {\n      if (listenerMap.hasOwnProperty(singleEventType)) {\n        this.off(singleEventType, selector, handler);\n      }\n    }\n    return this;\n  }\n  listenerList = listenerMap[eventType];\n  if (!listenerList || !listenerList.length) {\n    return this;\n  }\n\n  // Remove only parameter matches\n  // if specified\n  for (i = listenerList.length - 1; i >= 0; i--) {\n    listener = listenerList[i];\n    if ((!selector || selector === listener.selector) && (!handler || handler === listener.handler)) {\n      this._removedListeners.push(listener);\n      listenerList.splice(i, 1);\n    }\n  }\n\n  // All listeners removed\n  if (!listenerList.length) {\n    delete listenerMap[eventType];\n\n    // Remove the main handler\n    if (this.rootElement) {\n      this.rootElement.removeEventListener(eventType, this.handle, useCapture);\n    }\n  }\n  return this;\n};\n\n/**\n * Handle an arbitrary event.\n *\n * @param {Event} event\n */\nDelegate.prototype.handle = function (event) {\n  let i;\n  let l;\n  const type = event.type;\n  let root;\n  let phase;\n  let listener;\n  let returned;\n  let listenerList = [];\n  let target;\n  const eventIgnore = 'ftLabsDelegateIgnore';\n  if (event[eventIgnore] === true) {\n    return;\n  }\n  target = event.target;\n\n  // Hardcode value of Node.TEXT_NODE\n  // as not defined in IE8\n  if (target.nodeType === 3) {\n    target = target.parentNode;\n  }\n\n  // Handle SVG <use> elements in IE\n  if (target.correspondingUseElement) {\n    target = target.correspondingUseElement;\n  }\n  root = this.rootElement;\n  phase = event.eventPhase || (event.target !== event.currentTarget ? 3 : 2);\n\n  // eslint-disable-next-line default-case\n  switch (phase) {\n    case 1:\n      //Event.CAPTURING_PHASE:\n      listenerList = this.listenerMap[1][type];\n      break;\n    case 2:\n      //Event.AT_TARGET:\n      if (this.listenerMap[0] && this.listenerMap[0][type]) {\n        listenerList = listenerList.concat(this.listenerMap[0][type]);\n      }\n      if (this.listenerMap[1] && this.listenerMap[1][type]) {\n        listenerList = listenerList.concat(this.listenerMap[1][type]);\n      }\n      break;\n    case 3:\n      //Event.BUBBLING_PHASE:\n      listenerList = this.listenerMap[0][type];\n      break;\n  }\n  let toFire = [];\n\n  // Need to continuously check\n  // that the specific list is\n  // still populated in case one\n  // of the callbacks actually\n  // causes the list to be destroyed.\n  l = listenerList.length;\n  while (target && l) {\n    for (i = 0; i < l; i++) {\n      listener = listenerList[i];\n\n      // Bail from this loop if\n      // the length changed and\n      // no more listeners are\n      // defined between i and l.\n      if (!listener) {\n        break;\n      }\n      if (target.tagName && [\"button\", \"input\", \"select\", \"textarea\"].indexOf(target.tagName.toLowerCase()) > -1 && target.hasAttribute(\"disabled\")) {\n        // Remove things that have previously fired\n        toFire = [];\n      }\n      // Check for match and fire\n      // the event if there's one\n      //\n      // TODO:MCG:20120117: Need a way\n      // to check if event#stopImmediatePropagation\n      // was called. If so, break both loops.\n      else if (listener.matcher.call(target, listener.matcherParam, target)) {\n        toFire.push([event, target, listener]);\n      }\n    }\n\n    // TODO:MCG:20120117: Need a way to\n    // check if event#stopPropagation\n    // was called. If so, break looping\n    // through the DOM. Stop if the\n    // delegation root has been reached\n    if (target === root) {\n      break;\n    }\n    l = listenerList.length;\n\n    // Fall back to parentNode since SVG children have no parentElement in IE\n    target = target.parentElement || target.parentNode;\n\n    // Do not traverse up to document root when using parentNode, though\n    if (target instanceof HTMLDocument) {\n      break;\n    }\n  }\n  let ret;\n  for (i = 0; i < toFire.length; i++) {\n    // Has it been removed during while the event function was fired\n    if (this._removedListeners.indexOf(toFire[i][2]) > -1) {\n      continue;\n    }\n    returned = this.fire.apply(this, toFire[i]);\n\n    // Stop propagation to subsequent\n    // callbacks if the callback returned\n    // false\n    if (returned === false) {\n      toFire[i][0][eventIgnore] = true;\n      toFire[i][0].preventDefault();\n      ret = false;\n      break;\n    }\n  }\n  return ret;\n};\n\n/**\n * Fire a listener on a target.\n *\n * @param {Event} event\n * @param {Node} target\n * @param {Object} listener\n * @returns {boolean}\n */\nDelegate.prototype.fire = function (event, target, listener) {\n  return listener.handler.call(target, event, target);\n};\n\n/**\n * Check whether an element\n * matches a tag selector.\n *\n * Tags are NOT case-sensitive,\n * except in XML (and XML-based\n * languages such as XHTML).\n *\n * @param {string} tagName The tag name to test against\n * @param {Element} element The element to test with\n * @returns boolean\n */\nfunction matchesTag(tagName, element) {\n  return tagName.toLowerCase() === element.tagName.toLowerCase();\n}\n\n/**\n * Check whether an element\n * matches the root.\n *\n * @param {?String} selector In this case this is always passed through as null and not used\n * @param {Element} element The element to test with\n * @returns boolean\n */\nfunction matchesRoot(selector, element) {\n  if (this.rootElement === window) {\n    return (\n      // Match the outer document (dispatched from document)\n      element === document ||\n      // The <html> element (dispatched from document.body or document.documentElement)\n      element === document.documentElement ||\n      // Or the window itself (dispatched from window)\n      element === window\n    );\n  }\n  return this.rootElement === element;\n}\n\n/**\n * Check whether the ID of\n * the element in 'this'\n * matches the given ID.\n *\n * IDs are case-sensitive.\n *\n * @param {string} id The ID to test against\n * @param {Element} element The element to test with\n * @returns boolean\n */\nfunction matchesId(id, element) {\n  return id === element.id;\n}\n\n/**\n * Short hand for off()\n * and root(), ie both\n * with no parameters\n *\n * @return void\n */\nDelegate.prototype.destroy = function () {\n  this.off();\n  this.root();\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (Delegate);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZTZiMTljZDMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZnRkb21kZWxlZ2F0ZS9tYWluLmpzPzUwYjAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBET00gZXZlbnQgZGVsZWdhdG9yXG4gKlxuICogVGhlIGRlbGVnYXRvciB3aWxsIGxpc3RlblxuICogZm9yIGV2ZW50cyB0aGF0IGJ1YmJsZSB1cFxuICogdG8gdGhlIHJvb3Qgbm9kZS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Tm9kZXxzdHJpbmd9IFtyb290XSBUaGUgcm9vdCBub2RlIG9yIGEgc2VsZWN0b3Igc3RyaW5nIG1hdGNoaW5nIHRoZSByb290IG5vZGVcbiAqL1xuZnVuY3Rpb24gRGVsZWdhdGUocm9vdCkge1xuXG5cdC8qKlxuXHQgKiBNYWludGFpbiBhIG1hcCBvZiBsaXN0ZW5lclxuXHQgKiBsaXN0cywga2V5ZWQgYnkgZXZlbnQgbmFtZS5cblx0ICpcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHR0aGlzLmxpc3RlbmVyTWFwID0gW3t9LCB7fV07XG5cdGlmIChyb290KSB7XG5cdFx0dGhpcy5yb290KHJvb3QpO1xuXHR9XG5cblx0LyoqIEB0eXBlIGZ1bmN0aW9uKCkgKi9cblx0dGhpcy5oYW5kbGUgPSBEZWxlZ2F0ZS5wcm90b3R5cGUuaGFuZGxlLmJpbmQodGhpcyk7XG5cblx0Ly8gQ2FjaGUgb2YgZXZlbnQgbGlzdGVuZXJzIHJlbW92ZWQgZHVyaW5nIGFuIGV2ZW50IGN5Y2xlXG5cdHRoaXMuX3JlbW92ZWRMaXN0ZW5lcnMgPSBbXTtcbn1cblxuLyoqXG4gKiBTdGFydCBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICogb24gdGhlIHByb3ZpZGVkIERPTSBlbGVtZW50XG4gKlxuICogQHBhcmFtICB7Tm9kZXxzdHJpbmd9IFtyb290XSBUaGUgcm9vdCBub2RlIG9yIGEgc2VsZWN0b3Igc3RyaW5nIG1hdGNoaW5nIHRoZSByb290IG5vZGVcbiAqIEByZXR1cm5zIHtEZWxlZ2F0ZX0gVGhpcyBtZXRob2QgaXMgY2hhaW5hYmxlXG4gKi9cbkRlbGVnYXRlLnByb3RvdHlwZS5yb290ID0gZnVuY3Rpb24gKHJvb3QpIHtcblx0Y29uc3QgbGlzdGVuZXJNYXAgPSB0aGlzLmxpc3RlbmVyTWFwO1xuXHRsZXQgZXZlbnRUeXBlO1xuXG5cdC8vIFJlbW92ZSBtYXN0ZXIgZXZlbnQgbGlzdGVuZXJzXG5cdGlmICh0aGlzLnJvb3RFbGVtZW50KSB7XG5cdFx0Zm9yIChldmVudFR5cGUgaW4gbGlzdGVuZXJNYXBbMV0pIHtcblx0XHRcdGlmIChsaXN0ZW5lck1hcFsxXS5oYXNPd25Qcm9wZXJ0eShldmVudFR5cGUpKSB7XG5cdFx0XHRcdHRoaXMucm9vdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIHRoaXMuaGFuZGxlLCB0cnVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Zm9yIChldmVudFR5cGUgaW4gbGlzdGVuZXJNYXBbMF0pIHtcblx0XHRcdGlmIChsaXN0ZW5lck1hcFswXS5oYXNPd25Qcm9wZXJ0eShldmVudFR5cGUpKSB7XG5cdFx0XHRcdHRoaXMucm9vdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIHRoaXMuaGFuZGxlLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gSWYgbm8gcm9vdCBvciByb290IGlzIG5vdFxuXHQvLyBhIGRvbSBub2RlLCB0aGVuIHJlbW92ZSBpbnRlcm5hbFxuXHQvLyByb290IHJlZmVyZW5jZSBhbmQgZXhpdCBoZXJlXG5cdGlmICghcm9vdCB8fCAhcm9vdC5hZGRFdmVudExpc3RlbmVyKSB7XG5cdFx0aWYgKHRoaXMucm9vdEVsZW1lbnQpIHtcblx0XHRcdGRlbGV0ZSB0aGlzLnJvb3RFbGVtZW50O1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgcm9vdCBub2RlIGF0IHdoaWNoXG5cdCAqIGxpc3RlbmVycyBhcmUgYXR0YWNoZWQuXG5cdCAqXG5cdCAqIEB0eXBlIE5vZGVcblx0ICovXG5cdHRoaXMucm9vdEVsZW1lbnQgPSByb290O1xuXG5cdC8vIFNldCB1cCBtYXN0ZXIgZXZlbnQgbGlzdGVuZXJzXG5cdGZvciAoZXZlbnRUeXBlIGluIGxpc3RlbmVyTWFwWzFdKSB7XG5cdFx0aWYgKGxpc3RlbmVyTWFwWzFdLmhhc093blByb3BlcnR5KGV2ZW50VHlwZSkpIHtcblx0XHRcdHRoaXMucm9vdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIHRoaXMuaGFuZGxlLCB0cnVlKTtcblx0XHR9XG5cdH1cblx0Zm9yIChldmVudFR5cGUgaW4gbGlzdGVuZXJNYXBbMF0pIHtcblx0XHRpZiAobGlzdGVuZXJNYXBbMF0uaGFzT3duUHJvcGVydHkoZXZlbnRUeXBlKSkge1xuXHRcdFx0dGhpcy5yb290RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgdGhpcy5oYW5kbGUsIGZhbHNlKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZVxuICogQHJldHVybnMgYm9vbGVhblxuICovXG5EZWxlZ2F0ZS5wcm90b3R5cGUuY2FwdHVyZUZvclR5cGUgPSBmdW5jdGlvbiAoZXZlbnRUeXBlKSB7XG5cdHJldHVybiBbJ2JsdXInLCAnZXJyb3InLCAnZm9jdXMnLCAnbG9hZCcsICdyZXNpemUnLCAnc2Nyb2xsJ10uaW5kZXhPZihldmVudFR5cGUpICE9PSAtMTtcbn07XG5cbi8qKlxuICogQXR0YWNoIGEgaGFuZGxlciB0byBvbmVcbiAqIGV2ZW50IGZvciBhbGwgZWxlbWVudHNcbiAqIHRoYXQgbWF0Y2ggdGhlIHNlbGVjdG9yLFxuICogbm93IG9yIGluIHRoZSBmdXR1cmVcbiAqXG4gKiBUaGUgaGFuZGxlciBmdW5jdGlvbiByZWNlaXZlc1xuICogdGhyZWUgYXJndW1lbnRzOiB0aGUgRE9NIGV2ZW50XG4gKiBvYmplY3QsIHRoZSBub2RlIHRoYXQgbWF0Y2hlZFxuICogdGhlIHNlbGVjdG9yIHdoaWxlIHRoZSBldmVudFxuICogd2FzIGJ1YmJsaW5nIGFuZCBhIHJlZmVyZW5jZVxuICogdG8gaXRzZWxmLiBXaXRoaW4gdGhlIGhhbmRsZXIsXG4gKiAndGhpcycgaXMgZXF1YWwgdG8gdGhlIHNlY29uZFxuICogYXJndW1lbnQuXG4gKlxuICogVGhlIG5vZGUgdGhhdCBhY3R1YWxseSByZWNlaXZlZFxuICogdGhlIGV2ZW50IGNhbiBiZSBhY2Nlc3NlZCB2aWFcbiAqICdldmVudC50YXJnZXQnLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgTGlzdGVuIGZvciB0aGVzZSBldmVudHNcbiAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gc2VsZWN0b3IgT25seSBoYW5kbGUgZXZlbnRzIG9uIGVsZW1lbnRzIG1hdGNoaW5nIHRoaXMgc2VsZWN0b3IsIGlmIHVuZGVmaW5lZCBtYXRjaCByb290IGVsZW1lbnRcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gaGFuZGxlciBIYW5kbGVyIGZ1bmN0aW9uIC0gZXZlbnQgZGF0YSBwYXNzZWQgaGVyZSB3aWxsIGJlIGluIGV2ZW50LmRhdGFcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUNhcHR1cmVdIHNlZSAndXNlQ2FwdHVyZScgaW4gPGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudFRhcmdldC9hZGRFdmVudExpc3RlbmVyPlxuICogQHJldHVybnMge0RlbGVnYXRlfSBUaGlzIG1ldGhvZCBpcyBjaGFpbmFibGVcbiAqL1xuRGVsZWdhdGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgc2VsZWN0b3IsIGhhbmRsZXIsIHVzZUNhcHR1cmUpIHtcblx0bGV0IHJvb3Q7XG5cdGxldCBsaXN0ZW5lck1hcDtcblx0bGV0IG1hdGNoZXI7XG5cdGxldCBtYXRjaGVyUGFyYW07XG5cblx0aWYgKCFldmVudFR5cGUpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGV2ZW50IHR5cGU6ICcgKyBldmVudFR5cGUpO1xuXHR9XG5cblx0Ly8gaGFuZGxlciBjYW4gYmUgcGFzc2VkIGFzXG5cdC8vIHRoZSBzZWNvbmQgb3IgdGhpcmQgYXJndW1lbnRcblx0aWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHVzZUNhcHR1cmUgPSBoYW5kbGVyO1xuXHRcdGhhbmRsZXIgPSBzZWxlY3Rvcjtcblx0XHRzZWxlY3RvciA9IG51bGw7XG5cdH1cblxuXHQvLyBGYWxsYmFjayB0byBzZW5zaWJsZSBkZWZhdWx0c1xuXHQvLyBpZiB1c2VDYXB0dXJlIG5vdCBzZXRcblx0aWYgKHVzZUNhcHR1cmUgPT09IHVuZGVmaW5lZCkge1xuXHRcdHVzZUNhcHR1cmUgPSB0aGlzLmNhcHR1cmVGb3JUeXBlKGV2ZW50VHlwZSk7XG5cdH1cblxuXHRpZiAodHlwZW9mIGhhbmRsZXIgIT09ICdmdW5jdGlvbicpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdIYW5kbGVyIG11c3QgYmUgYSB0eXBlIG9mIEZ1bmN0aW9uJyk7XG5cdH1cblxuXHRyb290ID0gdGhpcy5yb290RWxlbWVudDtcblx0bGlzdGVuZXJNYXAgPSB0aGlzLmxpc3RlbmVyTWFwW3VzZUNhcHR1cmUgPyAxIDogMF07XG5cblx0Ly8gQWRkIG1hc3RlciBoYW5kbGVyIGZvciB0eXBlIGlmIG5vdCBjcmVhdGVkIHlldFxuXHRpZiAoIWxpc3RlbmVyTWFwW2V2ZW50VHlwZV0pIHtcblx0XHRpZiAocm9vdCkge1xuXHRcdFx0cm9vdC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgdGhpcy5oYW5kbGUsIHVzZUNhcHR1cmUpO1xuXHRcdH1cblx0XHRsaXN0ZW5lck1hcFtldmVudFR5cGVdID0gW107XG5cdH1cblxuXHRpZiAoIXNlbGVjdG9yKSB7XG5cdFx0bWF0Y2hlclBhcmFtID0gbnVsbDtcblxuXHRcdC8vIENPTVBMRVggLSBtYXRjaGVzUm9vdCBuZWVkcyB0byBoYXZlIGFjY2VzcyB0b1xuXHRcdC8vIHRoaXMucm9vdEVsZW1lbnQsIHNvIGJpbmQgdGhlIGZ1bmN0aW9uIHRvIHRoaXMuXG5cdFx0bWF0Y2hlciA9IG1hdGNoZXNSb290LmJpbmQodGhpcyk7XG5cblx0XHQvLyBDb21waWxlIGEgbWF0Y2hlciBmb3IgdGhlIGdpdmVuIHNlbGVjdG9yXG5cdH0gZWxzZSBpZiAoL15bYS16XSskL2kudGVzdChzZWxlY3RvcikpIHtcblx0XHRtYXRjaGVyUGFyYW0gPSBzZWxlY3Rvcjtcblx0XHRtYXRjaGVyID0gbWF0Y2hlc1RhZztcblx0fSBlbHNlIGlmICgvXiNbYS16MC05XFwtX10rJC9pLnRlc3Qoc2VsZWN0b3IpKSB7XG5cdFx0bWF0Y2hlclBhcmFtID0gc2VsZWN0b3Iuc2xpY2UoMSk7XG5cdFx0bWF0Y2hlciA9IG1hdGNoZXNJZDtcblx0fSBlbHNlIHtcblx0XHRtYXRjaGVyUGFyYW0gPSBzZWxlY3Rvcjtcblx0XHRtYXRjaGVyID0gRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcztcblx0fVxuXG5cdC8vIEFkZCB0byB0aGUgbGlzdCBvZiBsaXN0ZW5lcnNcblx0bGlzdGVuZXJNYXBbZXZlbnRUeXBlXS5wdXNoKHtcblx0XHRzZWxlY3Rvcjogc2VsZWN0b3IsXG5cdFx0aGFuZGxlcjogaGFuZGxlcixcblx0XHRtYXRjaGVyOiBtYXRjaGVyLFxuXHRcdG1hdGNoZXJQYXJhbTogbWF0Y2hlclBhcmFtXG5cdH0pO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gZXZlbnQgaGFuZGxlclxuICogZm9yIGVsZW1lbnRzIHRoYXQgbWF0Y2hcbiAqIHRoZSBzZWxlY3RvciwgZm9yZXZlclxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZXZlbnRUeXBlXSBSZW1vdmUgaGFuZGxlcnMgZm9yIGV2ZW50cyBtYXRjaGluZyB0aGlzIHR5cGUsIGNvbnNpZGVyaW5nIHRoZSBvdGhlciBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge3N0cmluZ30gW3NlbGVjdG9yXSBJZiB0aGlzIHBhcmFtZXRlciBpcyBvbWl0dGVkLCBvbmx5IGhhbmRsZXJzIHdoaWNoIG1hdGNoIHRoZSBvdGhlciB0d28gd2lsbCBiZSByZW1vdmVkXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IFtoYW5kbGVyXSBJZiB0aGlzIHBhcmFtZXRlciBpcyBvbWl0dGVkLCBvbmx5IGhhbmRsZXJzIHdoaWNoIG1hdGNoIHRoZSBwcmV2aW91cyB0d28gd2lsbCBiZSByZW1vdmVkXG4gKiBAcmV0dXJucyB7RGVsZWdhdGV9IFRoaXMgbWV0aG9kIGlzIGNoYWluYWJsZVxuICovXG5EZWxlZ2F0ZS5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgc2VsZWN0b3IsIGhhbmRsZXIsIHVzZUNhcHR1cmUpIHtcblx0bGV0IGk7XG5cdGxldCBsaXN0ZW5lcjtcblx0bGV0IGxpc3RlbmVyTWFwO1xuXHRsZXQgbGlzdGVuZXJMaXN0O1xuXHRsZXQgc2luZ2xlRXZlbnRUeXBlO1xuXG5cdC8vIEhhbmRsZXIgY2FuIGJlIHBhc3NlZCBhc1xuXHQvLyB0aGUgc2Vjb25kIG9yIHRoaXJkIGFyZ3VtZW50XG5cdGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09ICdmdW5jdGlvbicpIHtcblx0XHR1c2VDYXB0dXJlID0gaGFuZGxlcjtcblx0XHRoYW5kbGVyID0gc2VsZWN0b3I7XG5cdFx0c2VsZWN0b3IgPSBudWxsO1xuXHR9XG5cblx0Ly8gSWYgdXNlQ2FwdHVyZSBub3Qgc2V0LCByZW1vdmVcblx0Ly8gYWxsIGV2ZW50IGxpc3RlbmVyc1xuXHRpZiAodXNlQ2FwdHVyZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhpcy5vZmYoZXZlbnRUeXBlLCBzZWxlY3RvciwgaGFuZGxlciwgdHJ1ZSk7XG5cdFx0dGhpcy5vZmYoZXZlbnRUeXBlLCBzZWxlY3RvciwgaGFuZGxlciwgZmFsc2UpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0bGlzdGVuZXJNYXAgPSB0aGlzLmxpc3RlbmVyTWFwW3VzZUNhcHR1cmUgPyAxIDogMF07XG5cdGlmICghZXZlbnRUeXBlKSB7XG5cdFx0Zm9yIChzaW5nbGVFdmVudFR5cGUgaW4gbGlzdGVuZXJNYXApIHtcblx0XHRcdGlmIChsaXN0ZW5lck1hcC5oYXNPd25Qcm9wZXJ0eShzaW5nbGVFdmVudFR5cGUpKSB7XG5cdFx0XHRcdHRoaXMub2ZmKHNpbmdsZUV2ZW50VHlwZSwgc2VsZWN0b3IsIGhhbmRsZXIpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0bGlzdGVuZXJMaXN0ID0gbGlzdGVuZXJNYXBbZXZlbnRUeXBlXTtcblx0aWYgKCFsaXN0ZW5lckxpc3QgfHwgIWxpc3RlbmVyTGlzdC5sZW5ndGgpIHtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8vIFJlbW92ZSBvbmx5IHBhcmFtZXRlciBtYXRjaGVzXG5cdC8vIGlmIHNwZWNpZmllZFxuXHRmb3IgKGkgPSBsaXN0ZW5lckxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRsaXN0ZW5lciA9IGxpc3RlbmVyTGlzdFtpXTtcblxuXHRcdGlmICgoIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBsaXN0ZW5lci5zZWxlY3RvcikgJiYgKCFoYW5kbGVyIHx8IGhhbmRsZXIgPT09IGxpc3RlbmVyLmhhbmRsZXIpKSB7XG5cdFx0XHR0aGlzLl9yZW1vdmVkTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuXHRcdFx0bGlzdGVuZXJMaXN0LnNwbGljZShpLCAxKTtcblx0XHR9XG5cdH1cblxuXHQvLyBBbGwgbGlzdGVuZXJzIHJlbW92ZWRcblx0aWYgKCFsaXN0ZW5lckxpc3QubGVuZ3RoKSB7XG5cdFx0ZGVsZXRlIGxpc3RlbmVyTWFwW2V2ZW50VHlwZV07XG5cblx0XHQvLyBSZW1vdmUgdGhlIG1haW4gaGFuZGxlclxuXHRcdGlmICh0aGlzLnJvb3RFbGVtZW50KSB7XG5cdFx0XHR0aGlzLnJvb3RFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCB0aGlzLmhhbmRsZSwgdXNlQ2FwdHVyZSk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogSGFuZGxlIGFuIGFyYml0cmFyeSBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICovXG5EZWxlZ2F0ZS5wcm90b3R5cGUuaGFuZGxlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdGxldCBpO1xuXHRsZXQgbDtcblx0Y29uc3QgdHlwZSA9IGV2ZW50LnR5cGU7XG5cdGxldCByb290O1xuXHRsZXQgcGhhc2U7XG5cdGxldCBsaXN0ZW5lcjtcblx0bGV0IHJldHVybmVkO1xuXHRsZXQgbGlzdGVuZXJMaXN0ID0gW107XG5cdGxldCB0YXJnZXQ7XG5cdGNvbnN0IGV2ZW50SWdub3JlID0gJ2Z0TGFic0RlbGVnYXRlSWdub3JlJztcblxuXHRpZiAoZXZlbnRbZXZlbnRJZ25vcmVdID09PSB0cnVlKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuXG5cdC8vIEhhcmRjb2RlIHZhbHVlIG9mIE5vZGUuVEVYVF9OT0RFXG5cdC8vIGFzIG5vdCBkZWZpbmVkIGluIElFOFxuXHRpZiAodGFyZ2V0Lm5vZGVUeXBlID09PSAzKSB7XG5cdFx0dGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG5cdH1cblxuXHQvLyBIYW5kbGUgU1ZHIDx1c2U+IGVsZW1lbnRzIGluIElFXG5cdGlmICh0YXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQpIHtcblx0XHR0YXJnZXQgPSB0YXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQ7XG5cdH1cblxuXHRyb290ID0gdGhpcy5yb290RWxlbWVudDtcblxuXHRwaGFzZSA9IGV2ZW50LmV2ZW50UGhhc2UgfHwgKGV2ZW50LnRhcmdldCAhPT0gZXZlbnQuY3VycmVudFRhcmdldCA/IDMgOiAyKTtcblxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVmYXVsdC1jYXNlXG5cdHN3aXRjaCAocGhhc2UpIHtcblx0XHRjYXNlIDE6IC8vRXZlbnQuQ0FQVFVSSU5HX1BIQVNFOlxuXHRcdFx0bGlzdGVuZXJMaXN0ID0gdGhpcy5saXN0ZW5lck1hcFsxXVt0eXBlXTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgMjogLy9FdmVudC5BVF9UQVJHRVQ6XG5cdFx0XHRpZiAodGhpcy5saXN0ZW5lck1hcFswXSAmJiB0aGlzLmxpc3RlbmVyTWFwWzBdW3R5cGVdKSB7XG5cdFx0XHRcdGxpc3RlbmVyTGlzdCA9IGxpc3RlbmVyTGlzdC5jb25jYXQodGhpcy5saXN0ZW5lck1hcFswXVt0eXBlXSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5saXN0ZW5lck1hcFsxXSAmJiB0aGlzLmxpc3RlbmVyTWFwWzFdW3R5cGVdKSB7XG5cdFx0XHRcdGxpc3RlbmVyTGlzdCA9IGxpc3RlbmVyTGlzdC5jb25jYXQodGhpcy5saXN0ZW5lck1hcFsxXVt0eXBlXSk7XG5cdFx0XHR9XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIDM6IC8vRXZlbnQuQlVCQkxJTkdfUEhBU0U6XG5cdFx0XHRsaXN0ZW5lckxpc3QgPSB0aGlzLmxpc3RlbmVyTWFwWzBdW3R5cGVdO1xuXHRcdFx0YnJlYWs7XG5cdH1cblxuXHRsZXQgdG9GaXJlID0gW107XG5cblx0Ly8gTmVlZCB0byBjb250aW51b3VzbHkgY2hlY2tcblx0Ly8gdGhhdCB0aGUgc3BlY2lmaWMgbGlzdCBpc1xuXHQvLyBzdGlsbCBwb3B1bGF0ZWQgaW4gY2FzZSBvbmVcblx0Ly8gb2YgdGhlIGNhbGxiYWNrcyBhY3R1YWxseVxuXHQvLyBjYXVzZXMgdGhlIGxpc3QgdG8gYmUgZGVzdHJveWVkLlxuXHRsID0gbGlzdGVuZXJMaXN0Lmxlbmd0aDtcblx0d2hpbGUgKHRhcmdldCAmJiBsKSB7XG5cdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0bGlzdGVuZXIgPSBsaXN0ZW5lckxpc3RbaV07XG5cblx0XHRcdC8vIEJhaWwgZnJvbSB0aGlzIGxvb3AgaWZcblx0XHRcdC8vIHRoZSBsZW5ndGggY2hhbmdlZCBhbmRcblx0XHRcdC8vIG5vIG1vcmUgbGlzdGVuZXJzIGFyZVxuXHRcdFx0Ly8gZGVmaW5lZCBiZXR3ZWVuIGkgYW5kIGwuXG5cdFx0XHRpZiAoIWxpc3RlbmVyKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoXG5cdFx0XHRcdHRhcmdldC50YWdOYW1lICYmXG5cdFx0XHRcdFtcImJ1dHRvblwiLCBcImlucHV0XCIsIFwic2VsZWN0XCIsIFwidGV4dGFyZWFcIl0uaW5kZXhPZih0YXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSA+IC0xICYmXG5cdFx0XHRcdHRhcmdldC5oYXNBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKVxuXHRcdFx0KSB7XG5cdFx0XHRcdC8vIFJlbW92ZSB0aGluZ3MgdGhhdCBoYXZlIHByZXZpb3VzbHkgZmlyZWRcblx0XHRcdFx0dG9GaXJlID0gW107XG5cdFx0XHR9XG5cdFx0XHQvLyBDaGVjayBmb3IgbWF0Y2ggYW5kIGZpcmVcblx0XHRcdC8vIHRoZSBldmVudCBpZiB0aGVyZSdzIG9uZVxuXHRcdFx0Ly9cblx0XHRcdC8vIFRPRE86TUNHOjIwMTIwMTE3OiBOZWVkIGEgd2F5XG5cdFx0XHQvLyB0byBjaGVjayBpZiBldmVudCNzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25cblx0XHRcdC8vIHdhcyBjYWxsZWQuIElmIHNvLCBicmVhayBib3RoIGxvb3BzLlxuXHRcdFx0ZWxzZSBpZiAobGlzdGVuZXIubWF0Y2hlci5jYWxsKHRhcmdldCwgbGlzdGVuZXIubWF0Y2hlclBhcmFtLCB0YXJnZXQpKSB7XG5cdFx0XHRcdHRvRmlyZS5wdXNoKFtldmVudCwgdGFyZ2V0LCBsaXN0ZW5lcl0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFRPRE86TUNHOjIwMTIwMTE3OiBOZWVkIGEgd2F5IHRvXG5cdFx0Ly8gY2hlY2sgaWYgZXZlbnQjc3RvcFByb3BhZ2F0aW9uXG5cdFx0Ly8gd2FzIGNhbGxlZC4gSWYgc28sIGJyZWFrIGxvb3Bpbmdcblx0XHQvLyB0aHJvdWdoIHRoZSBET00uIFN0b3AgaWYgdGhlXG5cdFx0Ly8gZGVsZWdhdGlvbiByb290IGhhcyBiZWVuIHJlYWNoZWRcblx0XHRpZiAodGFyZ2V0ID09PSByb290KSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cblx0XHRsID0gbGlzdGVuZXJMaXN0Lmxlbmd0aDtcblxuXHRcdC8vIEZhbGwgYmFjayB0byBwYXJlbnROb2RlIHNpbmNlIFNWRyBjaGlsZHJlbiBoYXZlIG5vIHBhcmVudEVsZW1lbnQgaW4gSUVcblx0XHR0YXJnZXQgPSB0YXJnZXQucGFyZW50RWxlbWVudCB8fCB0YXJnZXQucGFyZW50Tm9kZTtcblxuXHRcdC8vIERvIG5vdCB0cmF2ZXJzZSB1cCB0byBkb2N1bWVudCByb290IHdoZW4gdXNpbmcgcGFyZW50Tm9kZSwgdGhvdWdoXG5cdFx0aWYgKHRhcmdldCBpbnN0YW5jZW9mIEhUTUxEb2N1bWVudCkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0bGV0IHJldDtcblxuXHRmb3IgKGkgPSAwOyBpIDwgdG9GaXJlLmxlbmd0aDsgaSsrKSB7XG5cdFx0Ly8gSGFzIGl0IGJlZW4gcmVtb3ZlZCBkdXJpbmcgd2hpbGUgdGhlIGV2ZW50IGZ1bmN0aW9uIHdhcyBmaXJlZFxuXHRcdGlmICh0aGlzLl9yZW1vdmVkTGlzdGVuZXJzLmluZGV4T2YodG9GaXJlW2ldWzJdKSA+IC0xKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cdFx0cmV0dXJuZWQgPSB0aGlzLmZpcmUuYXBwbHkodGhpcywgdG9GaXJlW2ldKTtcblxuXHRcdC8vIFN0b3AgcHJvcGFnYXRpb24gdG8gc3Vic2VxdWVudFxuXHRcdC8vIGNhbGxiYWNrcyBpZiB0aGUgY2FsbGJhY2sgcmV0dXJuZWRcblx0XHQvLyBmYWxzZVxuXHRcdGlmIChyZXR1cm5lZCA9PT0gZmFsc2UpIHtcblx0XHRcdHRvRmlyZVtpXVswXVtldmVudElnbm9yZV0gPSB0cnVlO1xuXHRcdFx0dG9GaXJlW2ldWzBdLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRyZXQgPSBmYWxzZTtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIEZpcmUgYSBsaXN0ZW5lciBvbiBhIHRhcmdldC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBsaXN0ZW5lclxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkRlbGVnYXRlLnByb3RvdHlwZS5maXJlID0gZnVuY3Rpb24gKGV2ZW50LCB0YXJnZXQsIGxpc3RlbmVyKSB7XG5cdHJldHVybiBsaXN0ZW5lci5oYW5kbGVyLmNhbGwodGFyZ2V0LCBldmVudCwgdGFyZ2V0KTtcbn07XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciBhbiBlbGVtZW50XG4gKiBtYXRjaGVzIGEgdGFnIHNlbGVjdG9yLlxuICpcbiAqIFRhZ3MgYXJlIE5PVCBjYXNlLXNlbnNpdGl2ZSxcbiAqIGV4Y2VwdCBpbiBYTUwgKGFuZCBYTUwtYmFzZWRcbiAqIGxhbmd1YWdlcyBzdWNoIGFzIFhIVE1MKS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnTmFtZSBUaGUgdGFnIG5hbWUgdG8gdGVzdCBhZ2FpbnN0XG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gdGVzdCB3aXRoXG4gKiBAcmV0dXJucyBib29sZWFuXG4gKi9cbmZ1bmN0aW9uIG1hdGNoZXNUYWcodGFnTmFtZSwgZWxlbWVudCkge1xuXHRyZXR1cm4gdGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGFuIGVsZW1lbnRcbiAqIG1hdGNoZXMgdGhlIHJvb3QuXG4gKlxuICogQHBhcmFtIHs/U3RyaW5nfSBzZWxlY3RvciBJbiB0aGlzIGNhc2UgdGhpcyBpcyBhbHdheXMgcGFzc2VkIHRocm91Z2ggYXMgbnVsbCBhbmQgbm90IHVzZWRcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB0byB0ZXN0IHdpdGhcbiAqIEByZXR1cm5zIGJvb2xlYW5cbiAqL1xuZnVuY3Rpb24gbWF0Y2hlc1Jvb3Qoc2VsZWN0b3IsIGVsZW1lbnQpIHtcblx0aWYgKHRoaXMucm9vdEVsZW1lbnQgPT09IHdpbmRvdykge1xuXHRcdHJldHVybiAoXG5cdFx0XHQvLyBNYXRjaCB0aGUgb3V0ZXIgZG9jdW1lbnQgKGRpc3BhdGNoZWQgZnJvbSBkb2N1bWVudClcblx0XHRcdGVsZW1lbnQgPT09IGRvY3VtZW50IHx8XG5cdFx0XHQvLyBUaGUgPGh0bWw+IGVsZW1lbnQgKGRpc3BhdGNoZWQgZnJvbSBkb2N1bWVudC5ib2R5IG9yIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudClcblx0XHRcdGVsZW1lbnQgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fFxuXHRcdFx0Ly8gT3IgdGhlIHdpbmRvdyBpdHNlbGYgKGRpc3BhdGNoZWQgZnJvbSB3aW5kb3cpXG5cdFx0XHRlbGVtZW50ID09PSB3aW5kb3dcblx0XHQpO1xuXHR9XG5cdHJldHVybiB0aGlzLnJvb3RFbGVtZW50ID09PSBlbGVtZW50O1xufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIElEIG9mXG4gKiB0aGUgZWxlbWVudCBpbiAndGhpcydcbiAqIG1hdGNoZXMgdGhlIGdpdmVuIElELlxuICpcbiAqIElEcyBhcmUgY2FzZS1zZW5zaXRpdmUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBJRCB0byB0ZXN0IGFnYWluc3RcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB0byB0ZXN0IHdpdGhcbiAqIEByZXR1cm5zIGJvb2xlYW5cbiAqL1xuZnVuY3Rpb24gbWF0Y2hlc0lkKGlkLCBlbGVtZW50KSB7XG5cdHJldHVybiBpZCA9PT0gZWxlbWVudC5pZDtcbn1cblxuLyoqXG4gKiBTaG9ydCBoYW5kIGZvciBvZmYoKVxuICogYW5kIHJvb3QoKSwgaWUgYm90aFxuICogd2l0aCBubyBwYXJhbWV0ZXJzXG4gKlxuICogQHJldHVybiB2b2lkXG4gKi9cbkRlbGVnYXRlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuXHR0aGlzLm9mZigpO1xuXHR0aGlzLnJvb3QoKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IERlbGVnYXRlO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///e6b19cd3\n");

/***/ }),

/***/ "efadc595":
/*!**********************************************************************!*\
  !*** ./node_modules/fontfaceobserver/fontfaceobserver.standalone.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("/* Font Face Observer v2.3.0 - © Bram Stein. License: BSD-3-Clause */(function () {\n  function p(a, c) {\n    document.addEventListener ? a.addEventListener(\"scroll\", c, !1) : a.attachEvent(\"scroll\", c);\n  }\n  function u(a) {\n    document.body ? a() : document.addEventListener ? document.addEventListener(\"DOMContentLoaded\", function b() {\n      document.removeEventListener(\"DOMContentLoaded\", b);\n      a();\n    }) : document.attachEvent(\"onreadystatechange\", function g() {\n      if (\"interactive\" == document.readyState || \"complete\" == document.readyState) document.detachEvent(\"onreadystatechange\", g), a();\n    });\n  }\n  ;\n  function w(a) {\n    this.g = document.createElement(\"div\");\n    this.g.setAttribute(\"aria-hidden\", \"true\");\n    this.g.appendChild(document.createTextNode(a));\n    this.h = document.createElement(\"span\");\n    this.i = document.createElement(\"span\");\n    this.m = document.createElement(\"span\");\n    this.j = document.createElement(\"span\");\n    this.l = -1;\n    this.h.style.cssText = \"max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;\";\n    this.i.style.cssText = \"max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;\";\n    this.j.style.cssText = \"max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;\";\n    this.m.style.cssText = \"display:inline-block;width:200%;height:200%;font-size:16px;max-width:none;\";\n    this.h.appendChild(this.m);\n    this.i.appendChild(this.j);\n    this.g.appendChild(this.h);\n    this.g.appendChild(this.i);\n  }\n  function x(a, c) {\n    a.g.style.cssText = \"max-width:none;min-width:20px;min-height:20px;display:inline-block;overflow:hidden;position:absolute;width:auto;margin:0;padding:0;top:-999px;white-space:nowrap;font-synthesis:none;font:\" + c + \";\";\n  }\n  function B(a) {\n    var c = a.g.offsetWidth,\n      b = c + 100;\n    a.j.style.width = b + \"px\";\n    a.i.scrollLeft = b;\n    a.h.scrollLeft = a.h.scrollWidth + 100;\n    return a.l !== c ? (a.l = c, !0) : !1;\n  }\n  function C(a, c) {\n    function b() {\n      var e = g;\n      B(e) && null !== e.g.parentNode && c(e.l);\n    }\n    var g = a;\n    p(a.h, b);\n    p(a.i, b);\n    B(a);\n  }\n  ;\n  function D(a, c, b) {\n    c = c || {};\n    b = b || window;\n    this.family = a;\n    this.style = c.style || \"normal\";\n    this.weight = c.weight || \"normal\";\n    this.stretch = c.stretch || \"normal\";\n    this.context = b;\n  }\n  var E = null,\n    F = null,\n    G = null,\n    H = null;\n  function I(a) {\n    null === F && (M(a) && /Apple/.test(window.navigator.vendor) ? (a = /AppleWebKit\\/([0-9]+)(?:\\.([0-9]+))(?:\\.([0-9]+))/.exec(window.navigator.userAgent), F = !!a && 603 > parseInt(a[1], 10)) : F = !1);\n    return F;\n  }\n  function M(a) {\n    null === H && (H = !!a.document.fonts);\n    return H;\n  }\n  function N(a, c) {\n    var b = a.style,\n      g = a.weight;\n    if (null === G) {\n      var e = document.createElement(\"div\");\n      try {\n        e.style.font = \"condensed 100px sans-serif\";\n      } catch (q) {}\n      G = \"\" !== e.style.font;\n    }\n    return [b, g, G ? a.stretch : \"\", \"100px\", c].join(\" \");\n  }\n  D.prototype.load = function (a, c) {\n    var b = this,\n      g = a || \"BESbswy\",\n      e = 0,\n      q = c || 3E3,\n      J = new Date().getTime();\n    return new Promise(function (K, L) {\n      if (M(b.context) && !I(b.context)) {\n        var O = new Promise(function (r, t) {\n            function h() {\n              new Date().getTime() - J >= q ? t(Error(\"\" + q + \"ms timeout exceeded\")) : b.context.document.fonts.load(N(b, '\"' + b.family + '\"'), g).then(function (n) {\n                1 <= n.length ? r() : setTimeout(h, 25);\n              }, t);\n            }\n            h();\n          }),\n          P = new Promise(function (r, t) {\n            e = setTimeout(function () {\n              t(Error(\"\" + q + \"ms timeout exceeded\"));\n            }, q);\n          });\n        Promise.race([P, O]).then(function () {\n          clearTimeout(e);\n          K(b);\n        }, L);\n      } else u(function () {\n        function r() {\n          var d;\n          if (d = -1 != k && -1 != l || -1 != k && -1 != m || -1 != l && -1 != m) (d = k != l && k != m && l != m) || (null === E && (d = /AppleWebKit\\/([0-9]+)(?:\\.([0-9]+))/.exec(window.navigator.userAgent), E = !!d && (536 > parseInt(d[1], 10) || 536 === parseInt(d[1], 10) && 11 >= parseInt(d[2], 10))), d = E && (k == y && l == y && m == y || k == z && l == z && m == z || k == A && l == A && m == A)), d = !d;\n          d && (null !== f.parentNode && f.parentNode.removeChild(f), clearTimeout(e), K(b));\n        }\n        function t() {\n          if (new Date().getTime() - J >= q) null !== f.parentNode && f.parentNode.removeChild(f), L(Error(\"\" + q + \"ms timeout exceeded\"));else {\n            var d = b.context.document.hidden;\n            if (!0 === d || void 0 === d) k = h.g.offsetWidth, l = n.g.offsetWidth, m = v.g.offsetWidth, r();\n            e = setTimeout(t, 50);\n          }\n        }\n        var h = new w(g),\n          n = new w(g),\n          v = new w(g),\n          k = -1,\n          l = -1,\n          m = -1,\n          y = -1,\n          z = -1,\n          A = -1,\n          f = document.createElement(\"div\");\n        f.dir = \"ltr\";\n        x(h, N(b, \"sans-serif\"));\n        x(n, N(b, \"serif\"));\n        x(v, N(b, \"monospace\"));\n        f.appendChild(h.g);\n        f.appendChild(n.g);\n        f.appendChild(v.g);\n        b.context.document.body.appendChild(f);\n        y = h.g.offsetWidth;\n        z = n.g.offsetWidth;\n        A = v.g.offsetWidth;\n        t();\n        C(h, function (d) {\n          k = d;\n          r();\n        });\n        x(h, N(b, '\"' + b.family + '\",sans-serif'));\n        C(n, function (d) {\n          l = d;\n          r();\n        });\n        x(n, N(b, '\"' + b.family + '\",serif'));\n        C(v, function (d) {\n          m = d;\n          r();\n        });\n        x(v, N(b, '\"' + b.family + '\",monospace'));\n      });\n    });\n  };\n   true ? module.exports = D : (undefined);\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWZhZGM1OTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZm9udGZhY2VvYnNlcnZlci9mb250ZmFjZW9ic2VydmVyLnN0YW5kYWxvbmUuanM/MDM0MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBGb250IEZhY2UgT2JzZXJ2ZXIgdjIuMy4wIC0gwqkgQnJhbSBTdGVpbi4gTGljZW5zZTogQlNELTMtQ2xhdXNlICovKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcChhLGMpe2RvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXI/YS5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsYywhMSk6YS5hdHRhY2hFdmVudChcInNjcm9sbFwiLGMpfWZ1bmN0aW9uIHUoYSl7ZG9jdW1lbnQuYm9keT9hKCk6ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcj9kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLGZ1bmN0aW9uIGIoKXtkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLGIpO2EoKX0pOmRvY3VtZW50LmF0dGFjaEV2ZW50KFwib25yZWFkeXN0YXRlY2hhbmdlXCIsZnVuY3Rpb24gZygpe2lmKFwiaW50ZXJhY3RpdmVcIj09ZG9jdW1lbnQucmVhZHlTdGF0ZXx8XCJjb21wbGV0ZVwiPT1kb2N1bWVudC5yZWFkeVN0YXRlKWRvY3VtZW50LmRldGFjaEV2ZW50KFwib25yZWFkeXN0YXRlY2hhbmdlXCIsZyksYSgpfSl9O2Z1bmN0aW9uIHcoYSl7dGhpcy5nPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7dGhpcy5nLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsXCJ0cnVlXCIpO3RoaXMuZy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShhKSk7dGhpcy5oPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO3RoaXMuaT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTt0aGlzLm09ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7dGhpcy5qPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO3RoaXMubD0tMTt0aGlzLmguc3R5bGUuY3NzVGV4dD1cIm1heC13aWR0aDpub25lO2Rpc3BsYXk6aW5saW5lLWJsb2NrO3Bvc2l0aW9uOmFic29sdXRlO2hlaWdodDoxMDAlO3dpZHRoOjEwMCU7b3ZlcmZsb3c6c2Nyb2xsO2ZvbnQtc2l6ZToxNnB4O1wiO3RoaXMuaS5zdHlsZS5jc3NUZXh0PVwibWF4LXdpZHRoOm5vbmU7ZGlzcGxheTppbmxpbmUtYmxvY2s7cG9zaXRpb246YWJzb2x1dGU7aGVpZ2h0OjEwMCU7d2lkdGg6MTAwJTtvdmVyZmxvdzpzY3JvbGw7Zm9udC1zaXplOjE2cHg7XCI7XG50aGlzLmouc3R5bGUuY3NzVGV4dD1cIm1heC13aWR0aDpub25lO2Rpc3BsYXk6aW5saW5lLWJsb2NrO3Bvc2l0aW9uOmFic29sdXRlO2hlaWdodDoxMDAlO3dpZHRoOjEwMCU7b3ZlcmZsb3c6c2Nyb2xsO2ZvbnQtc2l6ZToxNnB4O1wiO3RoaXMubS5zdHlsZS5jc3NUZXh0PVwiZGlzcGxheTppbmxpbmUtYmxvY2s7d2lkdGg6MjAwJTtoZWlnaHQ6MjAwJTtmb250LXNpemU6MTZweDttYXgtd2lkdGg6bm9uZTtcIjt0aGlzLmguYXBwZW5kQ2hpbGQodGhpcy5tKTt0aGlzLmkuYXBwZW5kQ2hpbGQodGhpcy5qKTt0aGlzLmcuYXBwZW5kQ2hpbGQodGhpcy5oKTt0aGlzLmcuYXBwZW5kQ2hpbGQodGhpcy5pKX1cbmZ1bmN0aW9uIHgoYSxjKXthLmcuc3R5bGUuY3NzVGV4dD1cIm1heC13aWR0aDpub25lO21pbi13aWR0aDoyMHB4O21pbi1oZWlnaHQ6MjBweDtkaXNwbGF5OmlubGluZS1ibG9jaztvdmVyZmxvdzpoaWRkZW47cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6YXV0bzttYXJnaW46MDtwYWRkaW5nOjA7dG9wOi05OTlweDt3aGl0ZS1zcGFjZTpub3dyYXA7Zm9udC1zeW50aGVzaXM6bm9uZTtmb250OlwiK2MrXCI7XCJ9ZnVuY3Rpb24gQihhKXt2YXIgYz1hLmcub2Zmc2V0V2lkdGgsYj1jKzEwMDthLmouc3R5bGUud2lkdGg9YitcInB4XCI7YS5pLnNjcm9sbExlZnQ9YjthLmguc2Nyb2xsTGVmdD1hLmguc2Nyb2xsV2lkdGgrMTAwO3JldHVybiBhLmwhPT1jPyhhLmw9YywhMCk6ITF9ZnVuY3Rpb24gQyhhLGMpe2Z1bmN0aW9uIGIoKXt2YXIgZT1nO0IoZSkmJm51bGwhPT1lLmcucGFyZW50Tm9kZSYmYyhlLmwpfXZhciBnPWE7cChhLmgsYik7cChhLmksYik7QihhKX07ZnVuY3Rpb24gRChhLGMsYil7Yz1jfHx7fTtiPWJ8fHdpbmRvdzt0aGlzLmZhbWlseT1hO3RoaXMuc3R5bGU9Yy5zdHlsZXx8XCJub3JtYWxcIjt0aGlzLndlaWdodD1jLndlaWdodHx8XCJub3JtYWxcIjt0aGlzLnN0cmV0Y2g9Yy5zdHJldGNofHxcIm5vcm1hbFwiO3RoaXMuY29udGV4dD1ifXZhciBFPW51bGwsRj1udWxsLEc9bnVsbCxIPW51bGw7ZnVuY3Rpb24gSShhKXtudWxsPT09RiYmKE0oYSkmJi9BcHBsZS8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnZlbmRvcik/KGE9L0FwcGxlV2ViS2l0XFwvKFswLTldKykoPzpcXC4oWzAtOV0rKSkoPzpcXC4oWzAtOV0rKSkvLmV4ZWMod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpLEY9ISFhJiY2MDM+cGFyc2VJbnQoYVsxXSwxMCkpOkY9ITEpO3JldHVybiBGfWZ1bmN0aW9uIE0oYSl7bnVsbD09PUgmJihIPSEhYS5kb2N1bWVudC5mb250cyk7cmV0dXJuIEh9XG5mdW5jdGlvbiBOKGEsYyl7dmFyIGI9YS5zdHlsZSxnPWEud2VpZ2h0O2lmKG51bGw9PT1HKXt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO3RyeXtlLnN0eWxlLmZvbnQ9XCJjb25kZW5zZWQgMTAwcHggc2Fucy1zZXJpZlwifWNhdGNoKHEpe31HPVwiXCIhPT1lLnN0eWxlLmZvbnR9cmV0dXJuW2IsZyxHP2Euc3RyZXRjaDpcIlwiLFwiMTAwcHhcIixjXS5qb2luKFwiIFwiKX1cbkQucHJvdG90eXBlLmxvYWQ9ZnVuY3Rpb24oYSxjKXt2YXIgYj10aGlzLGc9YXx8XCJCRVNic3d5XCIsZT0wLHE9Y3x8M0UzLEo9KG5ldyBEYXRlKS5nZXRUaW1lKCk7cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKEssTCl7aWYoTShiLmNvbnRleHQpJiYhSShiLmNvbnRleHQpKXt2YXIgTz1uZXcgUHJvbWlzZShmdW5jdGlvbihyLHQpe2Z1bmN0aW9uIGgoKXsobmV3IERhdGUpLmdldFRpbWUoKS1KPj1xP3QoRXJyb3IoXCJcIitxK1wibXMgdGltZW91dCBleGNlZWRlZFwiKSk6Yi5jb250ZXh0LmRvY3VtZW50LmZvbnRzLmxvYWQoTihiLCdcIicrYi5mYW1pbHkrJ1wiJyksZykudGhlbihmdW5jdGlvbihuKXsxPD1uLmxlbmd0aD9yKCk6c2V0VGltZW91dChoLDI1KX0sdCl9aCgpfSksUD1uZXcgUHJvbWlzZShmdW5jdGlvbihyLHQpe2U9c2V0VGltZW91dChmdW5jdGlvbigpe3QoRXJyb3IoXCJcIitxK1wibXMgdGltZW91dCBleGNlZWRlZFwiKSl9LHEpfSk7UHJvbWlzZS5yYWNlKFtQLE9dKS50aGVuKGZ1bmN0aW9uKCl7Y2xlYXJUaW1lb3V0KGUpO1xuSyhiKX0sTCl9ZWxzZSB1KGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcigpe3ZhciBkO2lmKGQ9LTEhPWsmJi0xIT1sfHwtMSE9ayYmLTEhPW18fC0xIT1sJiYtMSE9bSkoZD1rIT1sJiZrIT1tJiZsIT1tKXx8KG51bGw9PT1FJiYoZD0vQXBwbGVXZWJLaXRcXC8oWzAtOV0rKSg/OlxcLihbMC05XSspKS8uZXhlYyh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCksRT0hIWQmJig1MzY+cGFyc2VJbnQoZFsxXSwxMCl8fDUzNj09PXBhcnNlSW50KGRbMV0sMTApJiYxMT49cGFyc2VJbnQoZFsyXSwxMCkpKSxkPUUmJihrPT15JiZsPT15JiZtPT15fHxrPT16JiZsPT16JiZtPT16fHxrPT1BJiZsPT1BJiZtPT1BKSksZD0hZDtkJiYobnVsbCE9PWYucGFyZW50Tm9kZSYmZi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGYpLGNsZWFyVGltZW91dChlKSxLKGIpKX1mdW5jdGlvbiB0KCl7aWYoKG5ldyBEYXRlKS5nZXRUaW1lKCktSj49cSludWxsIT09Zi5wYXJlbnROb2RlJiZmLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZiksXG5MKEVycm9yKFwiXCIrcStcIm1zIHRpbWVvdXQgZXhjZWVkZWRcIikpO2Vsc2V7dmFyIGQ9Yi5jb250ZXh0LmRvY3VtZW50LmhpZGRlbjtpZighMD09PWR8fHZvaWQgMD09PWQpaz1oLmcub2Zmc2V0V2lkdGgsbD1uLmcub2Zmc2V0V2lkdGgsbT12Lmcub2Zmc2V0V2lkdGgscigpO2U9c2V0VGltZW91dCh0LDUwKX19dmFyIGg9bmV3IHcoZyksbj1uZXcgdyhnKSx2PW5ldyB3KGcpLGs9LTEsbD0tMSxtPS0xLHk9LTEsej0tMSxBPS0xLGY9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtmLmRpcj1cImx0clwiO3goaCxOKGIsXCJzYW5zLXNlcmlmXCIpKTt4KG4sTihiLFwic2VyaWZcIikpO3godixOKGIsXCJtb25vc3BhY2VcIikpO2YuYXBwZW5kQ2hpbGQoaC5nKTtmLmFwcGVuZENoaWxkKG4uZyk7Zi5hcHBlbmRDaGlsZCh2LmcpO2IuY29udGV4dC5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGYpO3k9aC5nLm9mZnNldFdpZHRoO3o9bi5nLm9mZnNldFdpZHRoO0E9di5nLm9mZnNldFdpZHRoO3QoKTtcbkMoaCxmdW5jdGlvbihkKXtrPWQ7cigpfSk7eChoLE4oYiwnXCInK2IuZmFtaWx5KydcIixzYW5zLXNlcmlmJykpO0MobixmdW5jdGlvbihkKXtsPWQ7cigpfSk7eChuLE4oYiwnXCInK2IuZmFtaWx5KydcIixzZXJpZicpKTtDKHYsZnVuY3Rpb24oZCl7bT1kO3IoKX0pO3godixOKGIsJ1wiJytiLmZhbWlseSsnXCIsbW9ub3NwYWNlJykpfSl9KX07XCJvYmplY3RcIj09PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9RDood2luZG93LkZvbnRGYWNlT2JzZXJ2ZXI9RCx3aW5kb3cuRm9udEZhY2VPYnNlcnZlci5wcm90b3R5cGUubG9hZD1ELnByb3RvdHlwZS5sb2FkKTt9KCkpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///efadc595\n");

/***/ }),

/***/ "f5ad1795":
/*!****************************************************!*\
  !*** ./node_modules/morphdom/dist/morphdom-esm.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nvar DOCUMENT_FRAGMENT_NODE = 11;\nfunction morphAttrs(fromNode, toNode) {\n  var toNodeAttrs = toNode.attributes;\n  var attr;\n  var attrName;\n  var attrNamespaceURI;\n  var attrValue;\n  var fromValue;\n\n  // document-fragments dont have attributes so lets not do anything\n  if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE || fromNode.nodeType === DOCUMENT_FRAGMENT_NODE) {\n    return;\n  }\n\n  // update attributes on original DOM element\n  for (var i = toNodeAttrs.length - 1; i >= 0; i--) {\n    attr = toNodeAttrs[i];\n    attrName = attr.name;\n    attrNamespaceURI = attr.namespaceURI;\n    attrValue = attr.value;\n    if (attrNamespaceURI) {\n      attrName = attr.localName || attrName;\n      fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);\n      if (fromValue !== attrValue) {\n        if (attr.prefix === 'xmlns') {\n          attrName = attr.name; // It's not allowed to set an attribute with the XMLNS namespace without specifying the `xmlns` prefix\n        }\n        fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);\n      }\n    } else {\n      fromValue = fromNode.getAttribute(attrName);\n      if (fromValue !== attrValue) {\n        fromNode.setAttribute(attrName, attrValue);\n      }\n    }\n  }\n\n  // Remove any extra attributes found on the original DOM element that\n  // weren't found on the target element.\n  var fromNodeAttrs = fromNode.attributes;\n  for (var d = fromNodeAttrs.length - 1; d >= 0; d--) {\n    attr = fromNodeAttrs[d];\n    attrName = attr.name;\n    attrNamespaceURI = attr.namespaceURI;\n    if (attrNamespaceURI) {\n      attrName = attr.localName || attrName;\n      if (!toNode.hasAttributeNS(attrNamespaceURI, attrName)) {\n        fromNode.removeAttributeNS(attrNamespaceURI, attrName);\n      }\n    } else {\n      if (!toNode.hasAttribute(attrName)) {\n        fromNode.removeAttribute(attrName);\n      }\n    }\n  }\n}\nvar range; // Create a range object for efficently rendering strings to elements.\nvar NS_XHTML = 'http://www.w3.org/1999/xhtml';\nvar doc = typeof document === 'undefined' ? undefined : document;\nvar HAS_TEMPLATE_SUPPORT = !!doc && 'content' in doc.createElement('template');\nvar HAS_RANGE_SUPPORT = !!doc && doc.createRange && 'createContextualFragment' in doc.createRange();\nfunction createFragmentFromTemplate(str) {\n  var template = doc.createElement('template');\n  template.innerHTML = str;\n  return template.content.childNodes[0];\n}\nfunction createFragmentFromRange(str) {\n  if (!range) {\n    range = doc.createRange();\n    range.selectNode(doc.body);\n  }\n  var fragment = range.createContextualFragment(str);\n  return fragment.childNodes[0];\n}\nfunction createFragmentFromWrap(str) {\n  var fragment = doc.createElement('body');\n  fragment.innerHTML = str;\n  return fragment.childNodes[0];\n}\n\n/**\n * This is about the same\n * var html = new DOMParser().parseFromString(str, 'text/html');\n * return html.body.firstChild;\n *\n * @method toElement\n * @param {String} str\n */\nfunction toElement(str) {\n  str = str.trim();\n  if (HAS_TEMPLATE_SUPPORT) {\n    // avoid restrictions on content for things like `<tr><th>Hi</th></tr>` which\n    // createContextualFragment doesn't support\n    // <template> support not available in IE\n    return createFragmentFromTemplate(str);\n  } else if (HAS_RANGE_SUPPORT) {\n    return createFragmentFromRange(str);\n  }\n  return createFragmentFromWrap(str);\n}\n\n/**\n * Returns true if two node's names are the same.\n *\n * NOTE: We don't bother checking `namespaceURI` because you will never find two HTML elements with the same\n *       nodeName and different namespace URIs.\n *\n * @param {Element} a\n * @param {Element} b The target element\n * @return {boolean}\n */\nfunction compareNodeNames(fromEl, toEl) {\n  var fromNodeName = fromEl.nodeName;\n  var toNodeName = toEl.nodeName;\n  var fromCodeStart, toCodeStart;\n  if (fromNodeName === toNodeName) {\n    return true;\n  }\n  fromCodeStart = fromNodeName.charCodeAt(0);\n  toCodeStart = toNodeName.charCodeAt(0);\n\n  // If the target element is a virtual DOM node or SVG node then we may\n  // need to normalize the tag name before comparing. Normal HTML elements that are\n  // in the \"http://www.w3.org/1999/xhtml\"\n  // are converted to upper case\n  if (fromCodeStart <= 90 && toCodeStart >= 97) {\n    // from is upper and to is lower\n    return fromNodeName === toNodeName.toUpperCase();\n  } else if (toCodeStart <= 90 && fromCodeStart >= 97) {\n    // to is upper and from is lower\n    return toNodeName === fromNodeName.toUpperCase();\n  } else {\n    return false;\n  }\n}\n\n/**\n * Create an element, optionally with a known namespace URI.\n *\n * @param {string} name the element name, e.g. 'div' or 'svg'\n * @param {string} [namespaceURI] the element's namespace URI, i.e. the value of\n * its `xmlns` attribute or its inferred namespace.\n *\n * @return {Element}\n */\nfunction createElementNS(name, namespaceURI) {\n  return !namespaceURI || namespaceURI === NS_XHTML ? doc.createElement(name) : doc.createElementNS(namespaceURI, name);\n}\n\n/**\n * Copies the children of one DOM element to another DOM element\n */\nfunction moveChildren(fromEl, toEl) {\n  var curChild = fromEl.firstChild;\n  while (curChild) {\n    var nextChild = curChild.nextSibling;\n    toEl.appendChild(curChild);\n    curChild = nextChild;\n  }\n  return toEl;\n}\nfunction syncBooleanAttrProp(fromEl, toEl, name) {\n  if (fromEl[name] !== toEl[name]) {\n    fromEl[name] = toEl[name];\n    if (fromEl[name]) {\n      fromEl.setAttribute(name, '');\n    } else {\n      fromEl.removeAttribute(name);\n    }\n  }\n}\nvar specialElHandlers = {\n  OPTION: function (fromEl, toEl) {\n    var parentNode = fromEl.parentNode;\n    if (parentNode) {\n      var parentName = parentNode.nodeName.toUpperCase();\n      if (parentName === 'OPTGROUP') {\n        parentNode = parentNode.parentNode;\n        parentName = parentNode && parentNode.nodeName.toUpperCase();\n      }\n      if (parentName === 'SELECT' && !parentNode.hasAttribute('multiple')) {\n        if (fromEl.hasAttribute('selected') && !toEl.selected) {\n          // Workaround for MS Edge bug where the 'selected' attribute can only be\n          // removed if set to a non-empty value:\n          // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n          fromEl.setAttribute('selected', 'selected');\n          fromEl.removeAttribute('selected');\n        }\n        // We have to reset select element's selectedIndex to -1, otherwise setting\n        // fromEl.selected using the syncBooleanAttrProp below has no effect.\n        // The correct selectedIndex will be set in the SELECT special handler below.\n        parentNode.selectedIndex = -1;\n      }\n    }\n    syncBooleanAttrProp(fromEl, toEl, 'selected');\n  },\n  /**\n   * The \"value\" attribute is special for the <input> element since it sets\n   * the initial value. Changing the \"value\" attribute without changing the\n   * \"value\" property will have no effect since it is only used to the set the\n   * initial value.  Similar for the \"checked\" attribute, and \"disabled\".\n   */\n  INPUT: function (fromEl, toEl) {\n    syncBooleanAttrProp(fromEl, toEl, 'checked');\n    syncBooleanAttrProp(fromEl, toEl, 'disabled');\n    if (fromEl.value !== toEl.value) {\n      fromEl.value = toEl.value;\n    }\n    if (!toEl.hasAttribute('value')) {\n      fromEl.removeAttribute('value');\n    }\n  },\n  TEXTAREA: function (fromEl, toEl) {\n    var newValue = toEl.value;\n    if (fromEl.value !== newValue) {\n      fromEl.value = newValue;\n    }\n    var firstChild = fromEl.firstChild;\n    if (firstChild) {\n      // Needed for IE. Apparently IE sets the placeholder as the\n      // node value and vise versa. This ignores an empty update.\n      var oldValue = firstChild.nodeValue;\n      if (oldValue == newValue || !newValue && oldValue == fromEl.placeholder) {\n        return;\n      }\n      firstChild.nodeValue = newValue;\n    }\n  },\n  SELECT: function (fromEl, toEl) {\n    if (!toEl.hasAttribute('multiple')) {\n      var selectedIndex = -1;\n      var i = 0;\n      // We have to loop through children of fromEl, not toEl since nodes can be moved\n      // from toEl to fromEl directly when morphing.\n      // At the time this special handler is invoked, all children have already been morphed\n      // and appended to / removed from fromEl, so using fromEl here is safe and correct.\n      var curChild = fromEl.firstChild;\n      var optgroup;\n      var nodeName;\n      while (curChild) {\n        nodeName = curChild.nodeName && curChild.nodeName.toUpperCase();\n        if (nodeName === 'OPTGROUP') {\n          optgroup = curChild;\n          curChild = optgroup.firstChild;\n        } else {\n          if (nodeName === 'OPTION') {\n            if (curChild.hasAttribute('selected')) {\n              selectedIndex = i;\n              break;\n            }\n            i++;\n          }\n          curChild = curChild.nextSibling;\n          if (!curChild && optgroup) {\n            curChild = optgroup.nextSibling;\n            optgroup = null;\n          }\n        }\n      }\n      fromEl.selectedIndex = selectedIndex;\n    }\n  }\n};\nvar ELEMENT_NODE = 1;\nvar DOCUMENT_FRAGMENT_NODE$1 = 11;\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\nfunction noop() {}\nfunction defaultGetNodeKey(node) {\n  if (node) {\n    return node.getAttribute && node.getAttribute('id') || node.id;\n  }\n}\nfunction morphdomFactory(morphAttrs) {\n  return function morphdom(fromNode, toNode, options) {\n    if (!options) {\n      options = {};\n    }\n    if (typeof toNode === 'string') {\n      if (fromNode.nodeName === '#document' || fromNode.nodeName === 'HTML' || fromNode.nodeName === 'BODY') {\n        var toNodeHtml = toNode;\n        toNode = doc.createElement('html');\n        toNode.innerHTML = toNodeHtml;\n      } else {\n        toNode = toElement(toNode);\n      }\n    } else if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE$1) {\n      toNode = toNode.firstElementChild;\n    }\n    var getNodeKey = options.getNodeKey || defaultGetNodeKey;\n    var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;\n    var onNodeAdded = options.onNodeAdded || noop;\n    var onBeforeElUpdated = options.onBeforeElUpdated || noop;\n    var onElUpdated = options.onElUpdated || noop;\n    var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;\n    var onNodeDiscarded = options.onNodeDiscarded || noop;\n    var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;\n    var skipFromChildren = options.skipFromChildren || noop;\n    var addChild = options.addChild || function (parent, child) {\n      return parent.appendChild(child);\n    };\n    var childrenOnly = options.childrenOnly === true;\n\n    // This object is used as a lookup to quickly find all keyed elements in the original DOM tree.\n    var fromNodesLookup = Object.create(null);\n    var keyedRemovalList = [];\n    function addKeyedRemoval(key) {\n      keyedRemovalList.push(key);\n    }\n    function walkDiscardedChildNodes(node, skipKeyedNodes) {\n      if (node.nodeType === ELEMENT_NODE) {\n        var curChild = node.firstChild;\n        while (curChild) {\n          var key = undefined;\n          if (skipKeyedNodes && (key = getNodeKey(curChild))) {\n            // If we are skipping keyed nodes then we add the key\n            // to a list so that it can be handled at the very end.\n            addKeyedRemoval(key);\n          } else {\n            // Only report the node as discarded if it is not keyed. We do this because\n            // at the end we loop through all keyed elements that were unmatched\n            // and then discard them in one final pass.\n            onNodeDiscarded(curChild);\n            if (curChild.firstChild) {\n              walkDiscardedChildNodes(curChild, skipKeyedNodes);\n            }\n          }\n          curChild = curChild.nextSibling;\n        }\n      }\n    }\n\n    /**\n    * Removes a DOM node out of the original DOM\n    *\n    * @param  {Node} node The node to remove\n    * @param  {Node} parentNode The nodes parent\n    * @param  {Boolean} skipKeyedNodes If true then elements with keys will be skipped and not discarded.\n    * @return {undefined}\n    */\n    function removeNode(node, parentNode, skipKeyedNodes) {\n      if (onBeforeNodeDiscarded(node) === false) {\n        return;\n      }\n      if (parentNode) {\n        parentNode.removeChild(node);\n      }\n      onNodeDiscarded(node);\n      walkDiscardedChildNodes(node, skipKeyedNodes);\n    }\n\n    // // TreeWalker implementation is no faster, but keeping this around in case this changes in the future\n    // function indexTree(root) {\n    //     var treeWalker = document.createTreeWalker(\n    //         root,\n    //         NodeFilter.SHOW_ELEMENT);\n    //\n    //     var el;\n    //     while((el = treeWalker.nextNode())) {\n    //         var key = getNodeKey(el);\n    //         if (key) {\n    //             fromNodesLookup[key] = el;\n    //         }\n    //     }\n    // }\n\n    // // NodeIterator implementation is no faster, but keeping this around in case this changes in the future\n    //\n    // function indexTree(node) {\n    //     var nodeIterator = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT);\n    //     var el;\n    //     while((el = nodeIterator.nextNode())) {\n    //         var key = getNodeKey(el);\n    //         if (key) {\n    //             fromNodesLookup[key] = el;\n    //         }\n    //     }\n    // }\n\n    function indexTree(node) {\n      if (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE$1) {\n        var curChild = node.firstChild;\n        while (curChild) {\n          var key = getNodeKey(curChild);\n          if (key) {\n            fromNodesLookup[key] = curChild;\n          }\n\n          // Walk recursively\n          indexTree(curChild);\n          curChild = curChild.nextSibling;\n        }\n      }\n    }\n    indexTree(fromNode);\n    function handleNodeAdded(el) {\n      onNodeAdded(el);\n      var curChild = el.firstChild;\n      while (curChild) {\n        var nextSibling = curChild.nextSibling;\n        var key = getNodeKey(curChild);\n        if (key) {\n          var unmatchedFromEl = fromNodesLookup[key];\n          // if we find a duplicate #id node in cache, replace `el` with cache value\n          // and morph it to the child node.\n          if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {\n            curChild.parentNode.replaceChild(unmatchedFromEl, curChild);\n            morphEl(unmatchedFromEl, curChild);\n          } else {\n            handleNodeAdded(curChild);\n          }\n        } else {\n          // recursively call for curChild and it's children to see if we find something in\n          // fromNodesLookup\n          handleNodeAdded(curChild);\n        }\n        curChild = nextSibling;\n      }\n    }\n    function cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey) {\n      // We have processed all of the \"to nodes\". If curFromNodeChild is\n      // non-null then we still have some from nodes left over that need\n      // to be removed\n      while (curFromNodeChild) {\n        var fromNextSibling = curFromNodeChild.nextSibling;\n        if (curFromNodeKey = getNodeKey(curFromNodeChild)) {\n          // Since the node is keyed it might be matched up later so we defer\n          // the actual removal to later\n          addKeyedRemoval(curFromNodeKey);\n        } else {\n          // NOTE: we skip nested keyed nodes from being removed since there is\n          //       still a chance they will be matched up later\n          removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n        }\n        curFromNodeChild = fromNextSibling;\n      }\n    }\n    function morphEl(fromEl, toEl, childrenOnly) {\n      var toElKey = getNodeKey(toEl);\n      if (toElKey) {\n        // If an element with an ID is being morphed then it will be in the final\n        // DOM so clear it out of the saved elements collection\n        delete fromNodesLookup[toElKey];\n      }\n      if (!childrenOnly) {\n        // optional\n        if (onBeforeElUpdated(fromEl, toEl) === false) {\n          return;\n        }\n\n        // update attributes on original DOM element first\n        morphAttrs(fromEl, toEl);\n        // optional\n        onElUpdated(fromEl);\n        if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {\n          return;\n        }\n      }\n      if (fromEl.nodeName !== 'TEXTAREA') {\n        morphChildren(fromEl, toEl);\n      } else {\n        specialElHandlers.TEXTAREA(fromEl, toEl);\n      }\n    }\n    function morphChildren(fromEl, toEl) {\n      var skipFrom = skipFromChildren(fromEl, toEl);\n      var curToNodeChild = toEl.firstChild;\n      var curFromNodeChild = fromEl.firstChild;\n      var curToNodeKey;\n      var curFromNodeKey;\n      var fromNextSibling;\n      var toNextSibling;\n      var matchingFromEl;\n\n      // walk the children\n      outer: while (curToNodeChild) {\n        toNextSibling = curToNodeChild.nextSibling;\n        curToNodeKey = getNodeKey(curToNodeChild);\n\n        // walk the fromNode children all the way through\n        while (!skipFrom && curFromNodeChild) {\n          fromNextSibling = curFromNodeChild.nextSibling;\n          if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {\n            curToNodeChild = toNextSibling;\n            curFromNodeChild = fromNextSibling;\n            continue outer;\n          }\n          curFromNodeKey = getNodeKey(curFromNodeChild);\n          var curFromNodeType = curFromNodeChild.nodeType;\n\n          // this means if the curFromNodeChild doesnt have a match with the curToNodeChild\n          var isCompatible = undefined;\n          if (curFromNodeType === curToNodeChild.nodeType) {\n            if (curFromNodeType === ELEMENT_NODE) {\n              // Both nodes being compared are Element nodes\n\n              if (curToNodeKey) {\n                // The target node has a key so we want to match it up with the correct element\n                // in the original DOM tree\n                if (curToNodeKey !== curFromNodeKey) {\n                  // The current element in the original DOM tree does not have a matching key so\n                  // let's check our lookup to see if there is a matching element in the original\n                  // DOM tree\n                  if (matchingFromEl = fromNodesLookup[curToNodeKey]) {\n                    if (fromNextSibling === matchingFromEl) {\n                      // Special case for single element removals. To avoid removing the original\n                      // DOM node out of the tree (since that can break CSS transitions, etc.),\n                      // we will instead discard the current node and wait until the next\n                      // iteration to properly match up the keyed target element with its matching\n                      // element in the original tree\n                      isCompatible = false;\n                    } else {\n                      // We found a matching keyed element somewhere in the original DOM tree.\n                      // Let's move the original DOM node into the current position and morph\n                      // it.\n\n                      // NOTE: We use insertBefore instead of replaceChild because we want to go through\n                      // the `removeNode()` function for the node that is being discarded so that\n                      // all lifecycle hooks are correctly invoked\n                      fromEl.insertBefore(matchingFromEl, curFromNodeChild);\n\n                      // fromNextSibling = curFromNodeChild.nextSibling;\n\n                      if (curFromNodeKey) {\n                        // Since the node is keyed it might be matched up later so we defer\n                        // the actual removal to later\n                        addKeyedRemoval(curFromNodeKey);\n                      } else {\n                        // NOTE: we skip nested keyed nodes from being removed since there is\n                        //       still a chance they will be matched up later\n                        removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                      }\n                      curFromNodeChild = matchingFromEl;\n                      curFromNodeKey = getNodeKey(curFromNodeChild);\n                    }\n                  } else {\n                    // The nodes are not compatible since the \"to\" node has a key and there\n                    // is no matching keyed node in the source tree\n                    isCompatible = false;\n                  }\n                }\n              } else if (curFromNodeKey) {\n                // The original has a key\n                isCompatible = false;\n              }\n              isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);\n              if (isCompatible) {\n                // We found compatible DOM elements so transform\n                // the current \"from\" node to match the current\n                // target DOM node.\n                // MORPH\n                morphEl(curFromNodeChild, curToNodeChild);\n              }\n            } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {\n              // Both nodes being compared are Text or Comment nodes\n              isCompatible = true;\n              // Simply update nodeValue on the original node to\n              // change the text value\n              if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {\n                curFromNodeChild.nodeValue = curToNodeChild.nodeValue;\n              }\n            }\n          }\n          if (isCompatible) {\n            // Advance both the \"to\" child and the \"from\" child since we found a match\n            // Nothing else to do as we already recursively called morphChildren above\n            curToNodeChild = toNextSibling;\n            curFromNodeChild = fromNextSibling;\n            continue outer;\n          }\n\n          // No compatible match so remove the old node from the DOM and continue trying to find a\n          // match in the original DOM. However, we only do this if the from node is not keyed\n          // since it is possible that a keyed node might match up with a node somewhere else in the\n          // target tree and we don't want to discard it just yet since it still might find a\n          // home in the final DOM tree. After everything is done we will remove any keyed nodes\n          // that didn't find a home\n          if (curFromNodeKey) {\n            // Since the node is keyed it might be matched up later so we defer\n            // the actual removal to later\n            addKeyedRemoval(curFromNodeKey);\n          } else {\n            // NOTE: we skip nested keyed nodes from being removed since there is\n            //       still a chance they will be matched up later\n            removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n          }\n          curFromNodeChild = fromNextSibling;\n        } // END: while(curFromNodeChild) {}\n\n        // If we got this far then we did not find a candidate match for\n        // our \"to node\" and we exhausted all of the children \"from\"\n        // nodes. Therefore, we will just append the current \"to\" node\n        // to the end\n        if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {\n          // MORPH\n          if (!skipFrom) {\n            addChild(fromEl, matchingFromEl);\n          }\n          morphEl(matchingFromEl, curToNodeChild);\n        } else {\n          var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);\n          if (onBeforeNodeAddedResult !== false) {\n            if (onBeforeNodeAddedResult) {\n              curToNodeChild = onBeforeNodeAddedResult;\n            }\n            if (curToNodeChild.actualize) {\n              curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);\n            }\n            addChild(fromEl, curToNodeChild);\n            handleNodeAdded(curToNodeChild);\n          }\n        }\n        curToNodeChild = toNextSibling;\n        curFromNodeChild = fromNextSibling;\n      }\n      cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey);\n      var specialElHandler = specialElHandlers[fromEl.nodeName];\n      if (specialElHandler) {\n        specialElHandler(fromEl, toEl);\n      }\n    } // END: morphChildren(...)\n\n    var morphedNode = fromNode;\n    var morphedNodeType = morphedNode.nodeType;\n    var toNodeType = toNode.nodeType;\n    if (!childrenOnly) {\n      // Handle the case where we are given two DOM nodes that are not\n      // compatible (e.g. <div> --> <span> or <div> --> TEXT)\n      if (morphedNodeType === ELEMENT_NODE) {\n        if (toNodeType === ELEMENT_NODE) {\n          if (!compareNodeNames(fromNode, toNode)) {\n            onNodeDiscarded(fromNode);\n            morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));\n          }\n        } else {\n          // Going from an element node to a text node\n          morphedNode = toNode;\n        }\n      } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) {\n        // Text or comment node\n        if (toNodeType === morphedNodeType) {\n          if (morphedNode.nodeValue !== toNode.nodeValue) {\n            morphedNode.nodeValue = toNode.nodeValue;\n          }\n          return morphedNode;\n        } else {\n          // Text node to something else\n          morphedNode = toNode;\n        }\n      }\n    }\n    if (morphedNode === toNode) {\n      // The \"to node\" was not compatible with the \"from node\" so we had to\n      // toss out the \"from node\" and use the \"to node\"\n      onNodeDiscarded(fromNode);\n    } else {\n      if (toNode.isSameNode && toNode.isSameNode(morphedNode)) {\n        return;\n      }\n      morphEl(morphedNode, toNode, childrenOnly);\n\n      // We now need to loop over any keyed nodes that might need to be\n      // removed. We only do the removal if we know that the keyed node\n      // never found a match. When a keyed node is matched up we remove\n      // it out of fromNodesLookup and we use fromNodesLookup to determine\n      // if a keyed node has been matched up or not\n      if (keyedRemovalList) {\n        for (var i = 0, len = keyedRemovalList.length; i < len; i++) {\n          var elToRemove = fromNodesLookup[keyedRemovalList[i]];\n          if (elToRemove) {\n            removeNode(elToRemove, elToRemove.parentNode, false);\n          }\n        }\n      }\n    }\n    if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {\n      if (morphedNode.actualize) {\n        morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);\n      }\n      // If we had to swap out the from node with a new node because the old\n      // node was not compatible with the target node then we need to\n      // replace the old DOM node in the original DOM tree. This is only\n      // possible if the original DOM node was part of a DOM tree which\n      // we know is the case if it has a parent node.\n      fromNode.parentNode.replaceChild(morphedNode, fromNode);\n    }\n    return morphedNode;\n  };\n}\nvar morphdom = morphdomFactory(morphAttrs);\n/* harmony default export */ __webpack_exports__[\"default\"] = (morphdom);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZjVhZDE3OTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9ycGhkb20vZGlzdC9tb3JwaGRvbS1lc20uanM/ZmFkOCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgRE9DVU1FTlRfRlJBR01FTlRfTk9ERSA9IDExO1xuXG5mdW5jdGlvbiBtb3JwaEF0dHJzKGZyb21Ob2RlLCB0b05vZGUpIHtcbiAgICB2YXIgdG9Ob2RlQXR0cnMgPSB0b05vZGUuYXR0cmlidXRlcztcbiAgICB2YXIgYXR0cjtcbiAgICB2YXIgYXR0ck5hbWU7XG4gICAgdmFyIGF0dHJOYW1lc3BhY2VVUkk7XG4gICAgdmFyIGF0dHJWYWx1ZTtcbiAgICB2YXIgZnJvbVZhbHVlO1xuXG4gICAgLy8gZG9jdW1lbnQtZnJhZ21lbnRzIGRvbnQgaGF2ZSBhdHRyaWJ1dGVzIHNvIGxldHMgbm90IGRvIGFueXRoaW5nXG4gICAgaWYgKHRvTm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSB8fCBmcm9tTm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBhdHRyaWJ1dGVzIG9uIG9yaWdpbmFsIERPTSBlbGVtZW50XG4gICAgZm9yICh2YXIgaSA9IHRvTm9kZUF0dHJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGF0dHIgPSB0b05vZGVBdHRyc1tpXTtcbiAgICAgICAgYXR0ck5hbWUgPSBhdHRyLm5hbWU7XG4gICAgICAgIGF0dHJOYW1lc3BhY2VVUkkgPSBhdHRyLm5hbWVzcGFjZVVSSTtcbiAgICAgICAgYXR0clZhbHVlID0gYXR0ci52YWx1ZTtcblxuICAgICAgICBpZiAoYXR0ck5hbWVzcGFjZVVSSSkge1xuICAgICAgICAgICAgYXR0ck5hbWUgPSBhdHRyLmxvY2FsTmFtZSB8fCBhdHRyTmFtZTtcbiAgICAgICAgICAgIGZyb21WYWx1ZSA9IGZyb21Ob2RlLmdldEF0dHJpYnV0ZU5TKGF0dHJOYW1lc3BhY2VVUkksIGF0dHJOYW1lKTtcblxuICAgICAgICAgICAgaWYgKGZyb21WYWx1ZSAhPT0gYXR0clZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHIucHJlZml4ID09PSAneG1sbnMnKXtcbiAgICAgICAgICAgICAgICAgICAgYXR0ck5hbWUgPSBhdHRyLm5hbWU7IC8vIEl0J3Mgbm90IGFsbG93ZWQgdG8gc2V0IGFuIGF0dHJpYnV0ZSB3aXRoIHRoZSBYTUxOUyBuYW1lc3BhY2Ugd2l0aG91dCBzcGVjaWZ5aW5nIHRoZSBgeG1sbnNgIHByZWZpeFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmcm9tTm9kZS5zZXRBdHRyaWJ1dGVOUyhhdHRyTmFtZXNwYWNlVVJJLCBhdHRyTmFtZSwgYXR0clZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyb21WYWx1ZSA9IGZyb21Ob2RlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChmcm9tVmFsdWUgIT09IGF0dHJWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGZyb21Ob2RlLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgYXR0clZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlbW92ZSBhbnkgZXh0cmEgYXR0cmlidXRlcyBmb3VuZCBvbiB0aGUgb3JpZ2luYWwgRE9NIGVsZW1lbnQgdGhhdFxuICAgIC8vIHdlcmVuJ3QgZm91bmQgb24gdGhlIHRhcmdldCBlbGVtZW50LlxuICAgIHZhciBmcm9tTm9kZUF0dHJzID0gZnJvbU5vZGUuYXR0cmlidXRlcztcblxuICAgIGZvciAodmFyIGQgPSBmcm9tTm9kZUF0dHJzLmxlbmd0aCAtIDE7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgIGF0dHIgPSBmcm9tTm9kZUF0dHJzW2RdO1xuICAgICAgICBhdHRyTmFtZSA9IGF0dHIubmFtZTtcbiAgICAgICAgYXR0ck5hbWVzcGFjZVVSSSA9IGF0dHIubmFtZXNwYWNlVVJJO1xuXG4gICAgICAgIGlmIChhdHRyTmFtZXNwYWNlVVJJKSB7XG4gICAgICAgICAgICBhdHRyTmFtZSA9IGF0dHIubG9jYWxOYW1lIHx8IGF0dHJOYW1lO1xuXG4gICAgICAgICAgICBpZiAoIXRvTm9kZS5oYXNBdHRyaWJ1dGVOUyhhdHRyTmFtZXNwYWNlVVJJLCBhdHRyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBmcm9tTm9kZS5yZW1vdmVBdHRyaWJ1dGVOUyhhdHRyTmFtZXNwYWNlVVJJLCBhdHRyTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRvTm9kZS5oYXNBdHRyaWJ1dGUoYXR0ck5hbWUpKSB7XG4gICAgICAgICAgICAgICAgZnJvbU5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxudmFyIHJhbmdlOyAvLyBDcmVhdGUgYSByYW5nZSBvYmplY3QgZm9yIGVmZmljZW50bHkgcmVuZGVyaW5nIHN0cmluZ3MgdG8gZWxlbWVudHMuXG52YXIgTlNfWEhUTUwgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCc7XG5cbnZhciBkb2MgPSB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogZG9jdW1lbnQ7XG52YXIgSEFTX1RFTVBMQVRFX1NVUFBPUlQgPSAhIWRvYyAmJiAnY29udGVudCcgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG52YXIgSEFTX1JBTkdFX1NVUFBPUlQgPSAhIWRvYyAmJiBkb2MuY3JlYXRlUmFuZ2UgJiYgJ2NyZWF0ZUNvbnRleHR1YWxGcmFnbWVudCcgaW4gZG9jLmNyZWF0ZVJhbmdlKCk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUZyYWdtZW50RnJvbVRlbXBsYXRlKHN0cikge1xuICAgIHZhciB0ZW1wbGF0ZSA9IGRvYy5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IHN0cjtcbiAgICByZXR1cm4gdGVtcGxhdGUuY29udGVudC5jaGlsZE5vZGVzWzBdO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGcmFnbWVudEZyb21SYW5nZShzdHIpIHtcbiAgICBpZiAoIXJhbmdlKSB7XG4gICAgICAgIHJhbmdlID0gZG9jLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgIHJhbmdlLnNlbGVjdE5vZGUoZG9jLmJvZHkpO1xuICAgIH1cblxuICAgIHZhciBmcmFnbWVudCA9IHJhbmdlLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudChzdHIpO1xuICAgIHJldHVybiBmcmFnbWVudC5jaGlsZE5vZGVzWzBdO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGcmFnbWVudEZyb21XcmFwKHN0cikge1xuICAgIHZhciBmcmFnbWVudCA9IGRvYy5jcmVhdGVFbGVtZW50KCdib2R5Jyk7XG4gICAgZnJhZ21lbnQuaW5uZXJIVE1MID0gc3RyO1xuICAgIHJldHVybiBmcmFnbWVudC5jaGlsZE5vZGVzWzBdO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgYWJvdXQgdGhlIHNhbWVcbiAqIHZhciBodG1sID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhzdHIsICd0ZXh0L2h0bWwnKTtcbiAqIHJldHVybiBodG1sLmJvZHkuZmlyc3RDaGlsZDtcbiAqXG4gKiBAbWV0aG9kIHRvRWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICovXG5mdW5jdGlvbiB0b0VsZW1lbnQoc3RyKSB7XG4gICAgc3RyID0gc3RyLnRyaW0oKTtcbiAgICBpZiAoSEFTX1RFTVBMQVRFX1NVUFBPUlQpIHtcbiAgICAgIC8vIGF2b2lkIHJlc3RyaWN0aW9ucyBvbiBjb250ZW50IGZvciB0aGluZ3MgbGlrZSBgPHRyPjx0aD5IaTwvdGg+PC90cj5gIHdoaWNoXG4gICAgICAvLyBjcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQgZG9lc24ndCBzdXBwb3J0XG4gICAgICAvLyA8dGVtcGxhdGU+IHN1cHBvcnQgbm90IGF2YWlsYWJsZSBpbiBJRVxuICAgICAgcmV0dXJuIGNyZWF0ZUZyYWdtZW50RnJvbVRlbXBsYXRlKHN0cik7XG4gICAgfSBlbHNlIGlmIChIQVNfUkFOR0VfU1VQUE9SVCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUZyYWdtZW50RnJvbVJhbmdlKHN0cik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUZyYWdtZW50RnJvbVdyYXAoc3RyKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdHdvIG5vZGUncyBuYW1lcyBhcmUgdGhlIHNhbWUuXG4gKlxuICogTk9URTogV2UgZG9uJ3QgYm90aGVyIGNoZWNraW5nIGBuYW1lc3BhY2VVUklgIGJlY2F1c2UgeW91IHdpbGwgbmV2ZXIgZmluZCB0d28gSFRNTCBlbGVtZW50cyB3aXRoIHRoZSBzYW1lXG4gKiAgICAgICBub2RlTmFtZSBhbmQgZGlmZmVyZW50IG5hbWVzcGFjZSBVUklzLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gYVxuICogQHBhcmFtIHtFbGVtZW50fSBiIFRoZSB0YXJnZXQgZWxlbWVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY29tcGFyZU5vZGVOYW1lcyhmcm9tRWwsIHRvRWwpIHtcbiAgICB2YXIgZnJvbU5vZGVOYW1lID0gZnJvbUVsLm5vZGVOYW1lO1xuICAgIHZhciB0b05vZGVOYW1lID0gdG9FbC5ub2RlTmFtZTtcbiAgICB2YXIgZnJvbUNvZGVTdGFydCwgdG9Db2RlU3RhcnQ7XG5cbiAgICBpZiAoZnJvbU5vZGVOYW1lID09PSB0b05vZGVOYW1lKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZyb21Db2RlU3RhcnQgPSBmcm9tTm9kZU5hbWUuY2hhckNvZGVBdCgwKTtcbiAgICB0b0NvZGVTdGFydCA9IHRvTm9kZU5hbWUuY2hhckNvZGVBdCgwKTtcblxuICAgIC8vIElmIHRoZSB0YXJnZXQgZWxlbWVudCBpcyBhIHZpcnR1YWwgRE9NIG5vZGUgb3IgU1ZHIG5vZGUgdGhlbiB3ZSBtYXlcbiAgICAvLyBuZWVkIHRvIG5vcm1hbGl6ZSB0aGUgdGFnIG5hbWUgYmVmb3JlIGNvbXBhcmluZy4gTm9ybWFsIEhUTUwgZWxlbWVudHMgdGhhdCBhcmVcbiAgICAvLyBpbiB0aGUgXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCJcbiAgICAvLyBhcmUgY29udmVydGVkIHRvIHVwcGVyIGNhc2VcbiAgICBpZiAoZnJvbUNvZGVTdGFydCA8PSA5MCAmJiB0b0NvZGVTdGFydCA+PSA5NykgeyAvLyBmcm9tIGlzIHVwcGVyIGFuZCB0byBpcyBsb3dlclxuICAgICAgICByZXR1cm4gZnJvbU5vZGVOYW1lID09PSB0b05vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgfSBlbHNlIGlmICh0b0NvZGVTdGFydCA8PSA5MCAmJiBmcm9tQ29kZVN0YXJ0ID49IDk3KSB7IC8vIHRvIGlzIHVwcGVyIGFuZCBmcm9tIGlzIGxvd2VyXG4gICAgICAgIHJldHVybiB0b05vZGVOYW1lID09PSBmcm9tTm9kZU5hbWUudG9VcHBlckNhc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBlbGVtZW50LCBvcHRpb25hbGx5IHdpdGggYSBrbm93biBuYW1lc3BhY2UgVVJJLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBlbGVtZW50IG5hbWUsIGUuZy4gJ2Rpdicgb3IgJ3N2ZydcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZXNwYWNlVVJJXSB0aGUgZWxlbWVudCdzIG5hbWVzcGFjZSBVUkksIGkuZS4gdGhlIHZhbHVlIG9mXG4gKiBpdHMgYHhtbG5zYCBhdHRyaWJ1dGUgb3IgaXRzIGluZmVycmVkIG5hbWVzcGFjZS5cbiAqXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMobmFtZSwgbmFtZXNwYWNlVVJJKSB7XG4gICAgcmV0dXJuICFuYW1lc3BhY2VVUkkgfHwgbmFtZXNwYWNlVVJJID09PSBOU19YSFRNTCA/XG4gICAgICAgIGRvYy5jcmVhdGVFbGVtZW50KG5hbWUpIDpcbiAgICAgICAgZG9jLmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VVUkksIG5hbWUpO1xufVxuXG4vKipcbiAqIENvcGllcyB0aGUgY2hpbGRyZW4gb2Ygb25lIERPTSBlbGVtZW50IHRvIGFub3RoZXIgRE9NIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gbW92ZUNoaWxkcmVuKGZyb21FbCwgdG9FbCkge1xuICAgIHZhciBjdXJDaGlsZCA9IGZyb21FbC5maXJzdENoaWxkO1xuICAgIHdoaWxlIChjdXJDaGlsZCkge1xuICAgICAgICB2YXIgbmV4dENoaWxkID0gY3VyQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgIHRvRWwuYXBwZW5kQ2hpbGQoY3VyQ2hpbGQpO1xuICAgICAgICBjdXJDaGlsZCA9IG5leHRDaGlsZDtcbiAgICB9XG4gICAgcmV0dXJuIHRvRWw7XG59XG5cbmZ1bmN0aW9uIHN5bmNCb29sZWFuQXR0clByb3AoZnJvbUVsLCB0b0VsLCBuYW1lKSB7XG4gICAgaWYgKGZyb21FbFtuYW1lXSAhPT0gdG9FbFtuYW1lXSkge1xuICAgICAgICBmcm9tRWxbbmFtZV0gPSB0b0VsW25hbWVdO1xuICAgICAgICBpZiAoZnJvbUVsW25hbWVdKSB7XG4gICAgICAgICAgICBmcm9tRWwuc2V0QXR0cmlidXRlKG5hbWUsICcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyb21FbC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbnZhciBzcGVjaWFsRWxIYW5kbGVycyA9IHtcbiAgICBPUFRJT046IGZ1bmN0aW9uKGZyb21FbCwgdG9FbCkge1xuICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IGZyb21FbC5wYXJlbnROb2RlO1xuICAgICAgICBpZiAocGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgdmFyIHBhcmVudE5hbWUgPSBwYXJlbnROb2RlLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAocGFyZW50TmFtZSA9PT0gJ09QVEdST1VQJykge1xuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgcGFyZW50TmFtZSA9IHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmVudE5hbWUgPT09ICdTRUxFQ1QnICYmICFwYXJlbnROb2RlLmhhc0F0dHJpYnV0ZSgnbXVsdGlwbGUnKSkge1xuICAgICAgICAgICAgICAgIGlmIChmcm9tRWwuaGFzQXR0cmlidXRlKCdzZWxlY3RlZCcpICYmICF0b0VsLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdvcmthcm91bmQgZm9yIE1TIEVkZ2UgYnVnIHdoZXJlIHRoZSAnc2VsZWN0ZWQnIGF0dHJpYnV0ZSBjYW4gb25seSBiZVxuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmVkIGlmIHNldCB0byBhIG5vbi1lbXB0eSB2YWx1ZTpcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9lbi11cy9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvMTIwODc2NzkvXG4gICAgICAgICAgICAgICAgICAgIGZyb21FbC5zZXRBdHRyaWJ1dGUoJ3NlbGVjdGVkJywgJ3NlbGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGZyb21FbC5yZW1vdmVBdHRyaWJ1dGUoJ3NlbGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gcmVzZXQgc2VsZWN0IGVsZW1lbnQncyBzZWxlY3RlZEluZGV4IHRvIC0xLCBvdGhlcndpc2Ugc2V0dGluZ1xuICAgICAgICAgICAgICAgIC8vIGZyb21FbC5zZWxlY3RlZCB1c2luZyB0aGUgc3luY0Jvb2xlYW5BdHRyUHJvcCBiZWxvdyBoYXMgbm8gZWZmZWN0LlxuICAgICAgICAgICAgICAgIC8vIFRoZSBjb3JyZWN0IHNlbGVjdGVkSW5kZXggd2lsbCBiZSBzZXQgaW4gdGhlIFNFTEVDVCBzcGVjaWFsIGhhbmRsZXIgYmVsb3cuXG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4ID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3luY0Jvb2xlYW5BdHRyUHJvcChmcm9tRWwsIHRvRWwsICdzZWxlY3RlZCcpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIFwidmFsdWVcIiBhdHRyaWJ1dGUgaXMgc3BlY2lhbCBmb3IgdGhlIDxpbnB1dD4gZWxlbWVudCBzaW5jZSBpdCBzZXRzXG4gICAgICogdGhlIGluaXRpYWwgdmFsdWUuIENoYW5naW5nIHRoZSBcInZhbHVlXCIgYXR0cmlidXRlIHdpdGhvdXQgY2hhbmdpbmcgdGhlXG4gICAgICogXCJ2YWx1ZVwiIHByb3BlcnR5IHdpbGwgaGF2ZSBubyBlZmZlY3Qgc2luY2UgaXQgaXMgb25seSB1c2VkIHRvIHRoZSBzZXQgdGhlXG4gICAgICogaW5pdGlhbCB2YWx1ZS4gIFNpbWlsYXIgZm9yIHRoZSBcImNoZWNrZWRcIiBhdHRyaWJ1dGUsIGFuZCBcImRpc2FibGVkXCIuXG4gICAgICovXG4gICAgSU5QVVQ6IGZ1bmN0aW9uKGZyb21FbCwgdG9FbCkge1xuICAgICAgICBzeW5jQm9vbGVhbkF0dHJQcm9wKGZyb21FbCwgdG9FbCwgJ2NoZWNrZWQnKTtcbiAgICAgICAgc3luY0Jvb2xlYW5BdHRyUHJvcChmcm9tRWwsIHRvRWwsICdkaXNhYmxlZCcpO1xuXG4gICAgICAgIGlmIChmcm9tRWwudmFsdWUgIT09IHRvRWwudmFsdWUpIHtcbiAgICAgICAgICAgIGZyb21FbC52YWx1ZSA9IHRvRWwudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRvRWwuaGFzQXR0cmlidXRlKCd2YWx1ZScpKSB7XG4gICAgICAgICAgICBmcm9tRWwucmVtb3ZlQXR0cmlidXRlKCd2YWx1ZScpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIFRFWFRBUkVBOiBmdW5jdGlvbihmcm9tRWwsIHRvRWwpIHtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gdG9FbC52YWx1ZTtcbiAgICAgICAgaWYgKGZyb21FbC52YWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgIGZyb21FbC52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZpcnN0Q2hpbGQgPSBmcm9tRWwuZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKGZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIC8vIE5lZWRlZCBmb3IgSUUuIEFwcGFyZW50bHkgSUUgc2V0cyB0aGUgcGxhY2Vob2xkZXIgYXMgdGhlXG4gICAgICAgICAgICAvLyBub2RlIHZhbHVlIGFuZCB2aXNlIHZlcnNhLiBUaGlzIGlnbm9yZXMgYW4gZW1wdHkgdXBkYXRlLlxuICAgICAgICAgICAgdmFyIG9sZFZhbHVlID0gZmlyc3RDaGlsZC5ub2RlVmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChvbGRWYWx1ZSA9PSBuZXdWYWx1ZSB8fCAoIW5ld1ZhbHVlICYmIG9sZFZhbHVlID09IGZyb21FbC5wbGFjZWhvbGRlcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZpcnN0Q2hpbGQubm9kZVZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFNFTEVDVDogZnVuY3Rpb24oZnJvbUVsLCB0b0VsKSB7XG4gICAgICAgIGlmICghdG9FbC5oYXNBdHRyaWJ1dGUoJ211bHRpcGxlJykpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZEluZGV4ID0gLTE7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIHRvIGxvb3AgdGhyb3VnaCBjaGlsZHJlbiBvZiBmcm9tRWwsIG5vdCB0b0VsIHNpbmNlIG5vZGVzIGNhbiBiZSBtb3ZlZFxuICAgICAgICAgICAgLy8gZnJvbSB0b0VsIHRvIGZyb21FbCBkaXJlY3RseSB3aGVuIG1vcnBoaW5nLlxuICAgICAgICAgICAgLy8gQXQgdGhlIHRpbWUgdGhpcyBzcGVjaWFsIGhhbmRsZXIgaXMgaW52b2tlZCwgYWxsIGNoaWxkcmVuIGhhdmUgYWxyZWFkeSBiZWVuIG1vcnBoZWRcbiAgICAgICAgICAgIC8vIGFuZCBhcHBlbmRlZCB0byAvIHJlbW92ZWQgZnJvbSBmcm9tRWwsIHNvIHVzaW5nIGZyb21FbCBoZXJlIGlzIHNhZmUgYW5kIGNvcnJlY3QuXG4gICAgICAgICAgICB2YXIgY3VyQ2hpbGQgPSBmcm9tRWwuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHZhciBvcHRncm91cDtcbiAgICAgICAgICAgIHZhciBub2RlTmFtZTtcbiAgICAgICAgICAgIHdoaWxlKGN1ckNoaWxkKSB7XG4gICAgICAgICAgICAgICAgbm9kZU5hbWUgPSBjdXJDaGlsZC5ub2RlTmFtZSAmJiBjdXJDaGlsZC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlTmFtZSA9PT0gJ09QVEdST1VQJykge1xuICAgICAgICAgICAgICAgICAgICBvcHRncm91cCA9IGN1ckNoaWxkO1xuICAgICAgICAgICAgICAgICAgICBjdXJDaGlsZCA9IG9wdGdyb3VwLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVOYW1lID09PSAnT1BUSU9OJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1ckNoaWxkLmhhc0F0dHJpYnV0ZSgnc2VsZWN0ZWQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1ckNoaWxkID0gY3VyQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3VyQ2hpbGQgJiYgb3B0Z3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ckNoaWxkID0gb3B0Z3JvdXAubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRncm91cCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZyb21FbC5zZWxlY3RlZEluZGV4ID0gc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBFTEVNRU5UX05PREUgPSAxO1xudmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREUkMSA9IDExO1xudmFyIFRFWFRfTk9ERSA9IDM7XG52YXIgQ09NTUVOVF9OT0RFID0gODtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIGRlZmF1bHRHZXROb2RlS2V5KG5vZGUpIHtcbiAgaWYgKG5vZGUpIHtcbiAgICByZXR1cm4gKG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKCdpZCcpKSB8fCBub2RlLmlkO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1vcnBoZG9tRmFjdG9yeShtb3JwaEF0dHJzKSB7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIG1vcnBoZG9tKGZyb21Ob2RlLCB0b05vZGUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRvTm9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChmcm9tTm9kZS5ub2RlTmFtZSA9PT0gJyNkb2N1bWVudCcgfHwgZnJvbU5vZGUubm9kZU5hbWUgPT09ICdIVE1MJyB8fCBmcm9tTm9kZS5ub2RlTmFtZSA9PT0gJ0JPRFknKSB7XG4gICAgICAgIHZhciB0b05vZGVIdG1sID0gdG9Ob2RlO1xuICAgICAgICB0b05vZGUgPSBkb2MuY3JlYXRlRWxlbWVudCgnaHRtbCcpO1xuICAgICAgICB0b05vZGUuaW5uZXJIVE1MID0gdG9Ob2RlSHRtbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvTm9kZSA9IHRvRWxlbWVudCh0b05vZGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodG9Ob2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFJDEpIHtcbiAgICAgIHRvTm9kZSA9IHRvTm9kZS5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICB9XG5cbiAgICB2YXIgZ2V0Tm9kZUtleSA9IG9wdGlvbnMuZ2V0Tm9kZUtleSB8fCBkZWZhdWx0R2V0Tm9kZUtleTtcbiAgICB2YXIgb25CZWZvcmVOb2RlQWRkZWQgPSBvcHRpb25zLm9uQmVmb3JlTm9kZUFkZGVkIHx8IG5vb3A7XG4gICAgdmFyIG9uTm9kZUFkZGVkID0gb3B0aW9ucy5vbk5vZGVBZGRlZCB8fCBub29wO1xuICAgIHZhciBvbkJlZm9yZUVsVXBkYXRlZCA9IG9wdGlvbnMub25CZWZvcmVFbFVwZGF0ZWQgfHwgbm9vcDtcbiAgICB2YXIgb25FbFVwZGF0ZWQgPSBvcHRpb25zLm9uRWxVcGRhdGVkIHx8IG5vb3A7XG4gICAgdmFyIG9uQmVmb3JlTm9kZURpc2NhcmRlZCA9IG9wdGlvbnMub25CZWZvcmVOb2RlRGlzY2FyZGVkIHx8IG5vb3A7XG4gICAgdmFyIG9uTm9kZURpc2NhcmRlZCA9IG9wdGlvbnMub25Ob2RlRGlzY2FyZGVkIHx8IG5vb3A7XG4gICAgdmFyIG9uQmVmb3JlRWxDaGlsZHJlblVwZGF0ZWQgPSBvcHRpb25zLm9uQmVmb3JlRWxDaGlsZHJlblVwZGF0ZWQgfHwgbm9vcDtcbiAgICB2YXIgc2tpcEZyb21DaGlsZHJlbiA9IG9wdGlvbnMuc2tpcEZyb21DaGlsZHJlbiB8fCBub29wO1xuICAgIHZhciBhZGRDaGlsZCA9IG9wdGlvbnMuYWRkQ2hpbGQgfHwgZnVuY3Rpb24ocGFyZW50LCBjaGlsZCl7IHJldHVybiBwYXJlbnQuYXBwZW5kQ2hpbGQoY2hpbGQpOyB9O1xuICAgIHZhciBjaGlsZHJlbk9ubHkgPSBvcHRpb25zLmNoaWxkcmVuT25seSA9PT0gdHJ1ZTtcblxuICAgIC8vIFRoaXMgb2JqZWN0IGlzIHVzZWQgYXMgYSBsb29rdXAgdG8gcXVpY2tseSBmaW5kIGFsbCBrZXllZCBlbGVtZW50cyBpbiB0aGUgb3JpZ2luYWwgRE9NIHRyZWUuXG4gICAgdmFyIGZyb21Ob2Rlc0xvb2t1cCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIGtleWVkUmVtb3ZhbExpc3QgPSBbXTtcblxuICAgIGZ1bmN0aW9uIGFkZEtleWVkUmVtb3ZhbChrZXkpIHtcbiAgICAgIGtleWVkUmVtb3ZhbExpc3QucHVzaChrZXkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdhbGtEaXNjYXJkZWRDaGlsZE5vZGVzKG5vZGUsIHNraXBLZXllZE5vZGVzKSB7XG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgIHZhciBjdXJDaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgd2hpbGUgKGN1ckNoaWxkKSB7XG5cbiAgICAgICAgICB2YXIga2V5ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgaWYgKHNraXBLZXllZE5vZGVzICYmIChrZXkgPSBnZXROb2RlS2V5KGN1ckNoaWxkKSkpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGFyZSBza2lwcGluZyBrZXllZCBub2RlcyB0aGVuIHdlIGFkZCB0aGUga2V5XG4gICAgICAgICAgICAvLyB0byBhIGxpc3Qgc28gdGhhdCBpdCBjYW4gYmUgaGFuZGxlZCBhdCB0aGUgdmVyeSBlbmQuXG4gICAgICAgICAgICBhZGRLZXllZFJlbW92YWwoa2V5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gT25seSByZXBvcnQgdGhlIG5vZGUgYXMgZGlzY2FyZGVkIGlmIGl0IGlzIG5vdCBrZXllZC4gV2UgZG8gdGhpcyBiZWNhdXNlXG4gICAgICAgICAgICAvLyBhdCB0aGUgZW5kIHdlIGxvb3AgdGhyb3VnaCBhbGwga2V5ZWQgZWxlbWVudHMgdGhhdCB3ZXJlIHVubWF0Y2hlZFxuICAgICAgICAgICAgLy8gYW5kIHRoZW4gZGlzY2FyZCB0aGVtIGluIG9uZSBmaW5hbCBwYXNzLlxuICAgICAgICAgICAgb25Ob2RlRGlzY2FyZGVkKGN1ckNoaWxkKTtcbiAgICAgICAgICAgIGlmIChjdXJDaGlsZC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgIHdhbGtEaXNjYXJkZWRDaGlsZE5vZGVzKGN1ckNoaWxkLCBza2lwS2V5ZWROb2Rlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VyQ2hpbGQgPSBjdXJDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICogUmVtb3ZlcyBhIERPTSBub2RlIG91dCBvZiB0aGUgb3JpZ2luYWwgRE9NXG4gICAgKlxuICAgICogQHBhcmFtICB7Tm9kZX0gbm9kZSBUaGUgbm9kZSB0byByZW1vdmVcbiAgICAqIEBwYXJhbSAge05vZGV9IHBhcmVudE5vZGUgVGhlIG5vZGVzIHBhcmVudFxuICAgICogQHBhcmFtICB7Qm9vbGVhbn0gc2tpcEtleWVkTm9kZXMgSWYgdHJ1ZSB0aGVuIGVsZW1lbnRzIHdpdGgga2V5cyB3aWxsIGJlIHNraXBwZWQgYW5kIG5vdCBkaXNjYXJkZWQuXG4gICAgKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gICAgKi9cbiAgICBmdW5jdGlvbiByZW1vdmVOb2RlKG5vZGUsIHBhcmVudE5vZGUsIHNraXBLZXllZE5vZGVzKSB7XG4gICAgICBpZiAob25CZWZvcmVOb2RlRGlzY2FyZGVkKG5vZGUpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICAgIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICB9XG5cbiAgICAgIG9uTm9kZURpc2NhcmRlZChub2RlKTtcbiAgICAgIHdhbGtEaXNjYXJkZWRDaGlsZE5vZGVzKG5vZGUsIHNraXBLZXllZE5vZGVzKTtcbiAgICB9XG5cbiAgICAvLyAvLyBUcmVlV2Fsa2VyIGltcGxlbWVudGF0aW9uIGlzIG5vIGZhc3RlciwgYnV0IGtlZXBpbmcgdGhpcyBhcm91bmQgaW4gY2FzZSB0aGlzIGNoYW5nZXMgaW4gdGhlIGZ1dHVyZVxuICAgIC8vIGZ1bmN0aW9uIGluZGV4VHJlZShyb290KSB7XG4gICAgLy8gICAgIHZhciB0cmVlV2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihcbiAgICAvLyAgICAgICAgIHJvb3QsXG4gICAgLy8gICAgICAgICBOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCk7XG4gICAgLy9cbiAgICAvLyAgICAgdmFyIGVsO1xuICAgIC8vICAgICB3aGlsZSgoZWwgPSB0cmVlV2Fsa2VyLm5leHROb2RlKCkpKSB7XG4gICAgLy8gICAgICAgICB2YXIga2V5ID0gZ2V0Tm9kZUtleShlbCk7XG4gICAgLy8gICAgICAgICBpZiAoa2V5KSB7XG4gICAgLy8gICAgICAgICAgICAgZnJvbU5vZGVzTG9va3VwW2tleV0gPSBlbDtcbiAgICAvLyAgICAgICAgIH1cbiAgICAvLyAgICAgfVxuICAgIC8vIH1cblxuICAgIC8vIC8vIE5vZGVJdGVyYXRvciBpbXBsZW1lbnRhdGlvbiBpcyBubyBmYXN0ZXIsIGJ1dCBrZWVwaW5nIHRoaXMgYXJvdW5kIGluIGNhc2UgdGhpcyBjaGFuZ2VzIGluIHRoZSBmdXR1cmVcbiAgICAvL1xuICAgIC8vIGZ1bmN0aW9uIGluZGV4VHJlZShub2RlKSB7XG4gICAgLy8gICAgIHZhciBub2RlSXRlcmF0b3IgPSBkb2N1bWVudC5jcmVhdGVOb2RlSXRlcmF0b3Iobm9kZSwgTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQpO1xuICAgIC8vICAgICB2YXIgZWw7XG4gICAgLy8gICAgIHdoaWxlKChlbCA9IG5vZGVJdGVyYXRvci5uZXh0Tm9kZSgpKSkge1xuICAgIC8vICAgICAgICAgdmFyIGtleSA9IGdldE5vZGVLZXkoZWwpO1xuICAgIC8vICAgICAgICAgaWYgKGtleSkge1xuICAgIC8vICAgICAgICAgICAgIGZyb21Ob2Rlc0xvb2t1cFtrZXldID0gZWw7XG4gICAgLy8gICAgICAgICB9XG4gICAgLy8gICAgIH1cbiAgICAvLyB9XG5cbiAgICBmdW5jdGlvbiBpbmRleFRyZWUobm9kZSkge1xuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSB8fCBub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFJDEpIHtcbiAgICAgICAgdmFyIGN1ckNoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICB3aGlsZSAoY3VyQ2hpbGQpIHtcbiAgICAgICAgICB2YXIga2V5ID0gZ2V0Tm9kZUtleShjdXJDaGlsZCk7XG4gICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgZnJvbU5vZGVzTG9va3VwW2tleV0gPSBjdXJDaGlsZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBXYWxrIHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgaW5kZXhUcmVlKGN1ckNoaWxkKTtcblxuICAgICAgICAgIGN1ckNoaWxkID0gY3VyQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbmRleFRyZWUoZnJvbU5vZGUpO1xuXG4gICAgZnVuY3Rpb24gaGFuZGxlTm9kZUFkZGVkKGVsKSB7XG4gICAgICBvbk5vZGVBZGRlZChlbCk7XG5cbiAgICAgIHZhciBjdXJDaGlsZCA9IGVsLmZpcnN0Q2hpbGQ7XG4gICAgICB3aGlsZSAoY3VyQ2hpbGQpIHtcbiAgICAgICAgdmFyIG5leHRTaWJsaW5nID0gY3VyQ2hpbGQubmV4dFNpYmxpbmc7XG5cbiAgICAgICAgdmFyIGtleSA9IGdldE5vZGVLZXkoY3VyQ2hpbGQpO1xuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgdmFyIHVubWF0Y2hlZEZyb21FbCA9IGZyb21Ob2Rlc0xvb2t1cFtrZXldO1xuICAgICAgICAgIC8vIGlmIHdlIGZpbmQgYSBkdXBsaWNhdGUgI2lkIG5vZGUgaW4gY2FjaGUsIHJlcGxhY2UgYGVsYCB3aXRoIGNhY2hlIHZhbHVlXG4gICAgICAgICAgLy8gYW5kIG1vcnBoIGl0IHRvIHRoZSBjaGlsZCBub2RlLlxuICAgICAgICAgIGlmICh1bm1hdGNoZWRGcm9tRWwgJiYgY29tcGFyZU5vZGVOYW1lcyhjdXJDaGlsZCwgdW5tYXRjaGVkRnJvbUVsKSkge1xuICAgICAgICAgICAgY3VyQ2hpbGQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQodW5tYXRjaGVkRnJvbUVsLCBjdXJDaGlsZCk7XG4gICAgICAgICAgICBtb3JwaEVsKHVubWF0Y2hlZEZyb21FbCwgY3VyQ2hpbGQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVOb2RlQWRkZWQoY3VyQ2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyByZWN1cnNpdmVseSBjYWxsIGZvciBjdXJDaGlsZCBhbmQgaXQncyBjaGlsZHJlbiB0byBzZWUgaWYgd2UgZmluZCBzb21ldGhpbmcgaW5cbiAgICAgICAgICAvLyBmcm9tTm9kZXNMb29rdXBcbiAgICAgICAgICBoYW5kbGVOb2RlQWRkZWQoY3VyQ2hpbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VyQ2hpbGQgPSBuZXh0U2libGluZztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhbnVwRnJvbUVsKGZyb21FbCwgY3VyRnJvbU5vZGVDaGlsZCwgY3VyRnJvbU5vZGVLZXkpIHtcbiAgICAgIC8vIFdlIGhhdmUgcHJvY2Vzc2VkIGFsbCBvZiB0aGUgXCJ0byBub2Rlc1wiLiBJZiBjdXJGcm9tTm9kZUNoaWxkIGlzXG4gICAgICAvLyBub24tbnVsbCB0aGVuIHdlIHN0aWxsIGhhdmUgc29tZSBmcm9tIG5vZGVzIGxlZnQgb3ZlciB0aGF0IG5lZWRcbiAgICAgIC8vIHRvIGJlIHJlbW92ZWRcbiAgICAgIHdoaWxlIChjdXJGcm9tTm9kZUNoaWxkKSB7XG4gICAgICAgIHZhciBmcm9tTmV4dFNpYmxpbmcgPSBjdXJGcm9tTm9kZUNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICBpZiAoKGN1ckZyb21Ob2RlS2V5ID0gZ2V0Tm9kZUtleShjdXJGcm9tTm9kZUNoaWxkKSkpIHtcbiAgICAgICAgICAvLyBTaW5jZSB0aGUgbm9kZSBpcyBrZXllZCBpdCBtaWdodCBiZSBtYXRjaGVkIHVwIGxhdGVyIHNvIHdlIGRlZmVyXG4gICAgICAgICAgLy8gdGhlIGFjdHVhbCByZW1vdmFsIHRvIGxhdGVyXG4gICAgICAgICAgYWRkS2V5ZWRSZW1vdmFsKGN1ckZyb21Ob2RlS2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBOT1RFOiB3ZSBza2lwIG5lc3RlZCBrZXllZCBub2RlcyBmcm9tIGJlaW5nIHJlbW92ZWQgc2luY2UgdGhlcmUgaXNcbiAgICAgICAgICAvLyAgICAgICBzdGlsbCBhIGNoYW5jZSB0aGV5IHdpbGwgYmUgbWF0Y2hlZCB1cCBsYXRlclxuICAgICAgICAgIHJlbW92ZU5vZGUoY3VyRnJvbU5vZGVDaGlsZCwgZnJvbUVsLCB0cnVlIC8qIHNraXAga2V5ZWQgbm9kZXMgKi8pO1xuICAgICAgICB9XG4gICAgICAgIGN1ckZyb21Ob2RlQ2hpbGQgPSBmcm9tTmV4dFNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9ycGhFbChmcm9tRWwsIHRvRWwsIGNoaWxkcmVuT25seSkge1xuICAgICAgdmFyIHRvRWxLZXkgPSBnZXROb2RlS2V5KHRvRWwpO1xuXG4gICAgICBpZiAodG9FbEtleSkge1xuICAgICAgICAvLyBJZiBhbiBlbGVtZW50IHdpdGggYW4gSUQgaXMgYmVpbmcgbW9ycGhlZCB0aGVuIGl0IHdpbGwgYmUgaW4gdGhlIGZpbmFsXG4gICAgICAgIC8vIERPTSBzbyBjbGVhciBpdCBvdXQgb2YgdGhlIHNhdmVkIGVsZW1lbnRzIGNvbGxlY3Rpb25cbiAgICAgICAgZGVsZXRlIGZyb21Ob2Rlc0xvb2t1cFt0b0VsS2V5XTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjaGlsZHJlbk9ubHkpIHtcbiAgICAgICAgLy8gb3B0aW9uYWxcbiAgICAgICAgaWYgKG9uQmVmb3JlRWxVcGRhdGVkKGZyb21FbCwgdG9FbCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIGF0dHJpYnV0ZXMgb24gb3JpZ2luYWwgRE9NIGVsZW1lbnQgZmlyc3RcbiAgICAgICAgbW9ycGhBdHRycyhmcm9tRWwsIHRvRWwpO1xuICAgICAgICAvLyBvcHRpb25hbFxuICAgICAgICBvbkVsVXBkYXRlZChmcm9tRWwpO1xuXG4gICAgICAgIGlmIChvbkJlZm9yZUVsQ2hpbGRyZW5VcGRhdGVkKGZyb21FbCwgdG9FbCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmcm9tRWwubm9kZU5hbWUgIT09ICdURVhUQVJFQScpIHtcbiAgICAgICAgbW9ycGhDaGlsZHJlbihmcm9tRWwsIHRvRWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3BlY2lhbEVsSGFuZGxlcnMuVEVYVEFSRUEoZnJvbUVsLCB0b0VsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb3JwaENoaWxkcmVuKGZyb21FbCwgdG9FbCkge1xuICAgICAgdmFyIHNraXBGcm9tID0gc2tpcEZyb21DaGlsZHJlbihmcm9tRWwsIHRvRWwpO1xuICAgICAgdmFyIGN1clRvTm9kZUNoaWxkID0gdG9FbC5maXJzdENoaWxkO1xuICAgICAgdmFyIGN1ckZyb21Ob2RlQ2hpbGQgPSBmcm9tRWwuZmlyc3RDaGlsZDtcbiAgICAgIHZhciBjdXJUb05vZGVLZXk7XG4gICAgICB2YXIgY3VyRnJvbU5vZGVLZXk7XG5cbiAgICAgIHZhciBmcm9tTmV4dFNpYmxpbmc7XG4gICAgICB2YXIgdG9OZXh0U2libGluZztcbiAgICAgIHZhciBtYXRjaGluZ0Zyb21FbDtcblxuICAgICAgLy8gd2FsayB0aGUgY2hpbGRyZW5cbiAgICAgIG91dGVyOiB3aGlsZSAoY3VyVG9Ob2RlQ2hpbGQpIHtcbiAgICAgICAgdG9OZXh0U2libGluZyA9IGN1clRvTm9kZUNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICBjdXJUb05vZGVLZXkgPSBnZXROb2RlS2V5KGN1clRvTm9kZUNoaWxkKTtcblxuICAgICAgICAvLyB3YWxrIHRoZSBmcm9tTm9kZSBjaGlsZHJlbiBhbGwgdGhlIHdheSB0aHJvdWdoXG4gICAgICAgIHdoaWxlICghc2tpcEZyb20gJiYgY3VyRnJvbU5vZGVDaGlsZCkge1xuICAgICAgICAgIGZyb21OZXh0U2libGluZyA9IGN1ckZyb21Ob2RlQ2hpbGQubmV4dFNpYmxpbmc7XG5cbiAgICAgICAgICBpZiAoY3VyVG9Ob2RlQ2hpbGQuaXNTYW1lTm9kZSAmJiBjdXJUb05vZGVDaGlsZC5pc1NhbWVOb2RlKGN1ckZyb21Ob2RlQ2hpbGQpKSB7XG4gICAgICAgICAgICBjdXJUb05vZGVDaGlsZCA9IHRvTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkID0gZnJvbU5leHRTaWJsaW5nO1xuICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VyRnJvbU5vZGVLZXkgPSBnZXROb2RlS2V5KGN1ckZyb21Ob2RlQ2hpbGQpO1xuXG4gICAgICAgICAgdmFyIGN1ckZyb21Ob2RlVHlwZSA9IGN1ckZyb21Ob2RlQ2hpbGQubm9kZVR5cGU7XG5cbiAgICAgICAgICAvLyB0aGlzIG1lYW5zIGlmIHRoZSBjdXJGcm9tTm9kZUNoaWxkIGRvZXNudCBoYXZlIGEgbWF0Y2ggd2l0aCB0aGUgY3VyVG9Ob2RlQ2hpbGRcbiAgICAgICAgICB2YXIgaXNDb21wYXRpYmxlID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgaWYgKGN1ckZyb21Ob2RlVHlwZSA9PT0gY3VyVG9Ob2RlQ2hpbGQubm9kZVR5cGUpIHtcbiAgICAgICAgICAgIGlmIChjdXJGcm9tTm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAvLyBCb3RoIG5vZGVzIGJlaW5nIGNvbXBhcmVkIGFyZSBFbGVtZW50IG5vZGVzXG5cbiAgICAgICAgICAgICAgaWYgKGN1clRvTm9kZUtleSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSB0YXJnZXQgbm9kZSBoYXMgYSBrZXkgc28gd2Ugd2FudCB0byBtYXRjaCBpdCB1cCB3aXRoIHRoZSBjb3JyZWN0IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAvLyBpbiB0aGUgb3JpZ2luYWwgRE9NIHRyZWVcbiAgICAgICAgICAgICAgICBpZiAoY3VyVG9Ob2RlS2V5ICE9PSBjdXJGcm9tTm9kZUtleSkge1xuICAgICAgICAgICAgICAgICAgLy8gVGhlIGN1cnJlbnQgZWxlbWVudCBpbiB0aGUgb3JpZ2luYWwgRE9NIHRyZWUgZG9lcyBub3QgaGF2ZSBhIG1hdGNoaW5nIGtleSBzb1xuICAgICAgICAgICAgICAgICAgLy8gbGV0J3MgY2hlY2sgb3VyIGxvb2t1cCB0byBzZWUgaWYgdGhlcmUgaXMgYSBtYXRjaGluZyBlbGVtZW50IGluIHRoZSBvcmlnaW5hbFxuICAgICAgICAgICAgICAgICAgLy8gRE9NIHRyZWVcbiAgICAgICAgICAgICAgICAgIGlmICgobWF0Y2hpbmdGcm9tRWwgPSBmcm9tTm9kZXNMb29rdXBbY3VyVG9Ob2RlS2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyb21OZXh0U2libGluZyA9PT0gbWF0Y2hpbmdGcm9tRWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIHNpbmdsZSBlbGVtZW50IHJlbW92YWxzLiBUbyBhdm9pZCByZW1vdmluZyB0aGUgb3JpZ2luYWxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBET00gbm9kZSBvdXQgb2YgdGhlIHRyZWUgKHNpbmNlIHRoYXQgY2FuIGJyZWFrIENTUyB0cmFuc2l0aW9ucywgZXRjLiksXG4gICAgICAgICAgICAgICAgICAgICAgLy8gd2Ugd2lsbCBpbnN0ZWFkIGRpc2NhcmQgdGhlIGN1cnJlbnQgbm9kZSBhbmQgd2FpdCB1bnRpbCB0aGUgbmV4dFxuICAgICAgICAgICAgICAgICAgICAgIC8vIGl0ZXJhdGlvbiB0byBwcm9wZXJseSBtYXRjaCB1cCB0aGUga2V5ZWQgdGFyZ2V0IGVsZW1lbnQgd2l0aCBpdHMgbWF0Y2hpbmdcbiAgICAgICAgICAgICAgICAgICAgICAvLyBlbGVtZW50IGluIHRoZSBvcmlnaW5hbCB0cmVlXG4gICAgICAgICAgICAgICAgICAgICAgaXNDb21wYXRpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gV2UgZm91bmQgYSBtYXRjaGluZyBrZXllZCBlbGVtZW50IHNvbWV3aGVyZSBpbiB0aGUgb3JpZ2luYWwgRE9NIHRyZWUuXG4gICAgICAgICAgICAgICAgICAgICAgLy8gTGV0J3MgbW92ZSB0aGUgb3JpZ2luYWwgRE9NIG5vZGUgaW50byB0aGUgY3VycmVudCBwb3NpdGlvbiBhbmQgbW9ycGhcbiAgICAgICAgICAgICAgICAgICAgICAvLyBpdC5cblxuICAgICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IFdlIHVzZSBpbnNlcnRCZWZvcmUgaW5zdGVhZCBvZiByZXBsYWNlQ2hpbGQgYmVjYXVzZSB3ZSB3YW50IHRvIGdvIHRocm91Z2hcbiAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgYHJlbW92ZU5vZGUoKWAgZnVuY3Rpb24gZm9yIHRoZSBub2RlIHRoYXQgaXMgYmVpbmcgZGlzY2FyZGVkIHNvIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgICAvLyBhbGwgbGlmZWN5Y2xlIGhvb2tzIGFyZSBjb3JyZWN0bHkgaW52b2tlZFxuICAgICAgICAgICAgICAgICAgICAgIGZyb21FbC5pbnNlcnRCZWZvcmUobWF0Y2hpbmdGcm9tRWwsIGN1ckZyb21Ob2RlQ2hpbGQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgLy8gZnJvbU5leHRTaWJsaW5nID0gY3VyRnJvbU5vZGVDaGlsZC5uZXh0U2libGluZztcblxuICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJGcm9tTm9kZUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2luY2UgdGhlIG5vZGUgaXMga2V5ZWQgaXQgbWlnaHQgYmUgbWF0Y2hlZCB1cCBsYXRlciBzbyB3ZSBkZWZlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGFjdHVhbCByZW1vdmFsIHRvIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRLZXllZFJlbW92YWwoY3VyRnJvbU5vZGVLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiB3ZSBza2lwIG5lc3RlZCBrZXllZCBub2RlcyBmcm9tIGJlaW5nIHJlbW92ZWQgc2luY2UgdGhlcmUgaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgIHN0aWxsIGEgY2hhbmNlIHRoZXkgd2lsbCBiZSBtYXRjaGVkIHVwIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVOb2RlKGN1ckZyb21Ob2RlQ2hpbGQsIGZyb21FbCwgdHJ1ZSAvKiBza2lwIGtleWVkIG5vZGVzICovKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkID0gbWF0Y2hpbmdGcm9tRWw7XG4gICAgICAgICAgICAgICAgICAgICAgY3VyRnJvbU5vZGVLZXkgPSBnZXROb2RlS2V5KGN1ckZyb21Ob2RlQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbm9kZXMgYXJlIG5vdCBjb21wYXRpYmxlIHNpbmNlIHRoZSBcInRvXCIgbm9kZSBoYXMgYSBrZXkgYW5kIHRoZXJlXG4gICAgICAgICAgICAgICAgICAgIC8vIGlzIG5vIG1hdGNoaW5nIGtleWVkIG5vZGUgaW4gdGhlIHNvdXJjZSB0cmVlXG4gICAgICAgICAgICAgICAgICAgIGlzQ29tcGF0aWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJGcm9tTm9kZUtleSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBvcmlnaW5hbCBoYXMgYSBrZXlcbiAgICAgICAgICAgICAgICBpc0NvbXBhdGlibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlzQ29tcGF0aWJsZSA9IGlzQ29tcGF0aWJsZSAhPT0gZmFsc2UgJiYgY29tcGFyZU5vZGVOYW1lcyhjdXJGcm9tTm9kZUNoaWxkLCBjdXJUb05vZGVDaGlsZCk7XG4gICAgICAgICAgICAgIGlmIChpc0NvbXBhdGlibGUpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBmb3VuZCBjb21wYXRpYmxlIERPTSBlbGVtZW50cyBzbyB0cmFuc2Zvcm1cbiAgICAgICAgICAgICAgICAvLyB0aGUgY3VycmVudCBcImZyb21cIiBub2RlIHRvIG1hdGNoIHRoZSBjdXJyZW50XG4gICAgICAgICAgICAgICAgLy8gdGFyZ2V0IERPTSBub2RlLlxuICAgICAgICAgICAgICAgIC8vIE1PUlBIXG4gICAgICAgICAgICAgICAgbW9ycGhFbChjdXJGcm9tTm9kZUNoaWxkLCBjdXJUb05vZGVDaGlsZCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJGcm9tTm9kZVR5cGUgPT09IFRFWFRfTk9ERSB8fCBjdXJGcm9tTm9kZVR5cGUgPT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgIC8vIEJvdGggbm9kZXMgYmVpbmcgY29tcGFyZWQgYXJlIFRleHQgb3IgQ29tbWVudCBub2Rlc1xuICAgICAgICAgICAgICBpc0NvbXBhdGlibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAvLyBTaW1wbHkgdXBkYXRlIG5vZGVWYWx1ZSBvbiB0aGUgb3JpZ2luYWwgbm9kZSB0b1xuICAgICAgICAgICAgICAvLyBjaGFuZ2UgdGhlIHRleHQgdmFsdWVcbiAgICAgICAgICAgICAgaWYgKGN1ckZyb21Ob2RlQ2hpbGQubm9kZVZhbHVlICE9PSBjdXJUb05vZGVDaGlsZC5ub2RlVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkLm5vZGVWYWx1ZSA9IGN1clRvTm9kZUNoaWxkLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzQ29tcGF0aWJsZSkge1xuICAgICAgICAgICAgLy8gQWR2YW5jZSBib3RoIHRoZSBcInRvXCIgY2hpbGQgYW5kIHRoZSBcImZyb21cIiBjaGlsZCBzaW5jZSB3ZSBmb3VuZCBhIG1hdGNoXG4gICAgICAgICAgICAvLyBOb3RoaW5nIGVsc2UgdG8gZG8gYXMgd2UgYWxyZWFkeSByZWN1cnNpdmVseSBjYWxsZWQgbW9ycGhDaGlsZHJlbiBhYm92ZVxuICAgICAgICAgICAgY3VyVG9Ob2RlQ2hpbGQgPSB0b05leHRTaWJsaW5nO1xuICAgICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21OZXh0U2libGluZztcbiAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIE5vIGNvbXBhdGlibGUgbWF0Y2ggc28gcmVtb3ZlIHRoZSBvbGQgbm9kZSBmcm9tIHRoZSBET00gYW5kIGNvbnRpbnVlIHRyeWluZyB0byBmaW5kIGFcbiAgICAgICAgICAvLyBtYXRjaCBpbiB0aGUgb3JpZ2luYWwgRE9NLiBIb3dldmVyLCB3ZSBvbmx5IGRvIHRoaXMgaWYgdGhlIGZyb20gbm9kZSBpcyBub3Qga2V5ZWRcbiAgICAgICAgICAvLyBzaW5jZSBpdCBpcyBwb3NzaWJsZSB0aGF0IGEga2V5ZWQgbm9kZSBtaWdodCBtYXRjaCB1cCB3aXRoIGEgbm9kZSBzb21ld2hlcmUgZWxzZSBpbiB0aGVcbiAgICAgICAgICAvLyB0YXJnZXQgdHJlZSBhbmQgd2UgZG9uJ3Qgd2FudCB0byBkaXNjYXJkIGl0IGp1c3QgeWV0IHNpbmNlIGl0IHN0aWxsIG1pZ2h0IGZpbmQgYVxuICAgICAgICAgIC8vIGhvbWUgaW4gdGhlIGZpbmFsIERPTSB0cmVlLiBBZnRlciBldmVyeXRoaW5nIGlzIGRvbmUgd2Ugd2lsbCByZW1vdmUgYW55IGtleWVkIG5vZGVzXG4gICAgICAgICAgLy8gdGhhdCBkaWRuJ3QgZmluZCBhIGhvbWVcbiAgICAgICAgICBpZiAoY3VyRnJvbU5vZGVLZXkpIHtcbiAgICAgICAgICAgIC8vIFNpbmNlIHRoZSBub2RlIGlzIGtleWVkIGl0IG1pZ2h0IGJlIG1hdGNoZWQgdXAgbGF0ZXIgc28gd2UgZGVmZXJcbiAgICAgICAgICAgIC8vIHRoZSBhY3R1YWwgcmVtb3ZhbCB0byBsYXRlclxuICAgICAgICAgICAgYWRkS2V5ZWRSZW1vdmFsKGN1ckZyb21Ob2RlS2V5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTk9URTogd2Ugc2tpcCBuZXN0ZWQga2V5ZWQgbm9kZXMgZnJvbSBiZWluZyByZW1vdmVkIHNpbmNlIHRoZXJlIGlzXG4gICAgICAgICAgICAvLyAgICAgICBzdGlsbCBhIGNoYW5jZSB0aGV5IHdpbGwgYmUgbWF0Y2hlZCB1cCBsYXRlclxuICAgICAgICAgICAgcmVtb3ZlTm9kZShjdXJGcm9tTm9kZUNoaWxkLCBmcm9tRWwsIHRydWUgLyogc2tpcCBrZXllZCBub2RlcyAqLyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21OZXh0U2libGluZztcbiAgICAgICAgfSAvLyBFTkQ6IHdoaWxlKGN1ckZyb21Ob2RlQ2hpbGQpIHt9XG5cbiAgICAgICAgLy8gSWYgd2UgZ290IHRoaXMgZmFyIHRoZW4gd2UgZGlkIG5vdCBmaW5kIGEgY2FuZGlkYXRlIG1hdGNoIGZvclxuICAgICAgICAvLyBvdXIgXCJ0byBub2RlXCIgYW5kIHdlIGV4aGF1c3RlZCBhbGwgb2YgdGhlIGNoaWxkcmVuIFwiZnJvbVwiXG4gICAgICAgIC8vIG5vZGVzLiBUaGVyZWZvcmUsIHdlIHdpbGwganVzdCBhcHBlbmQgdGhlIGN1cnJlbnQgXCJ0b1wiIG5vZGVcbiAgICAgICAgLy8gdG8gdGhlIGVuZFxuICAgICAgICBpZiAoY3VyVG9Ob2RlS2V5ICYmIChtYXRjaGluZ0Zyb21FbCA9IGZyb21Ob2Rlc0xvb2t1cFtjdXJUb05vZGVLZXldKSAmJiBjb21wYXJlTm9kZU5hbWVzKG1hdGNoaW5nRnJvbUVsLCBjdXJUb05vZGVDaGlsZCkpIHtcbiAgICAgICAgICAvLyBNT1JQSFxuICAgICAgICAgIGlmKCFza2lwRnJvbSl7IGFkZENoaWxkKGZyb21FbCwgbWF0Y2hpbmdGcm9tRWwpOyB9XG4gICAgICAgICAgbW9ycGhFbChtYXRjaGluZ0Zyb21FbCwgY3VyVG9Ob2RlQ2hpbGQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBvbkJlZm9yZU5vZGVBZGRlZFJlc3VsdCA9IG9uQmVmb3JlTm9kZUFkZGVkKGN1clRvTm9kZUNoaWxkKTtcbiAgICAgICAgICBpZiAob25CZWZvcmVOb2RlQWRkZWRSZXN1bHQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAob25CZWZvcmVOb2RlQWRkZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgY3VyVG9Ob2RlQ2hpbGQgPSBvbkJlZm9yZU5vZGVBZGRlZFJlc3VsdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGN1clRvTm9kZUNoaWxkLmFjdHVhbGl6ZSkge1xuICAgICAgICAgICAgICBjdXJUb05vZGVDaGlsZCA9IGN1clRvTm9kZUNoaWxkLmFjdHVhbGl6ZShmcm9tRWwub3duZXJEb2N1bWVudCB8fCBkb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkQ2hpbGQoZnJvbUVsLCBjdXJUb05vZGVDaGlsZCk7XG4gICAgICAgICAgICBoYW5kbGVOb2RlQWRkZWQoY3VyVG9Ob2RlQ2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGN1clRvTm9kZUNoaWxkID0gdG9OZXh0U2libGluZztcbiAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21OZXh0U2libGluZztcbiAgICAgIH1cblxuICAgICAgY2xlYW51cEZyb21FbChmcm9tRWwsIGN1ckZyb21Ob2RlQ2hpbGQsIGN1ckZyb21Ob2RlS2V5KTtcblxuICAgICAgdmFyIHNwZWNpYWxFbEhhbmRsZXIgPSBzcGVjaWFsRWxIYW5kbGVyc1tmcm9tRWwubm9kZU5hbWVdO1xuICAgICAgaWYgKHNwZWNpYWxFbEhhbmRsZXIpIHtcbiAgICAgICAgc3BlY2lhbEVsSGFuZGxlcihmcm9tRWwsIHRvRWwpO1xuICAgICAgfVxuICAgIH0gLy8gRU5EOiBtb3JwaENoaWxkcmVuKC4uLilcblxuICAgIHZhciBtb3JwaGVkTm9kZSA9IGZyb21Ob2RlO1xuICAgIHZhciBtb3JwaGVkTm9kZVR5cGUgPSBtb3JwaGVkTm9kZS5ub2RlVHlwZTtcbiAgICB2YXIgdG9Ob2RlVHlwZSA9IHRvTm9kZS5ub2RlVHlwZTtcblxuICAgIGlmICghY2hpbGRyZW5Pbmx5KSB7XG4gICAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgd2UgYXJlIGdpdmVuIHR3byBET00gbm9kZXMgdGhhdCBhcmUgbm90XG4gICAgICAvLyBjb21wYXRpYmxlIChlLmcuIDxkaXY+IC0tPiA8c3Bhbj4gb3IgPGRpdj4gLS0+IFRFWFQpXG4gICAgICBpZiAobW9ycGhlZE5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgaWYgKHRvTm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgIGlmICghY29tcGFyZU5vZGVOYW1lcyhmcm9tTm9kZSwgdG9Ob2RlKSkge1xuICAgICAgICAgICAgb25Ob2RlRGlzY2FyZGVkKGZyb21Ob2RlKTtcbiAgICAgICAgICAgIG1vcnBoZWROb2RlID0gbW92ZUNoaWxkcmVuKGZyb21Ob2RlLCBjcmVhdGVFbGVtZW50TlModG9Ob2RlLm5vZGVOYW1lLCB0b05vZGUubmFtZXNwYWNlVVJJKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEdvaW5nIGZyb20gYW4gZWxlbWVudCBub2RlIHRvIGEgdGV4dCBub2RlXG4gICAgICAgICAgbW9ycGhlZE5vZGUgPSB0b05vZGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobW9ycGhlZE5vZGVUeXBlID09PSBURVhUX05PREUgfHwgbW9ycGhlZE5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHsgLy8gVGV4dCBvciBjb21tZW50IG5vZGVcbiAgICAgICAgaWYgKHRvTm9kZVR5cGUgPT09IG1vcnBoZWROb2RlVHlwZSkge1xuICAgICAgICAgIGlmIChtb3JwaGVkTm9kZS5ub2RlVmFsdWUgIT09IHRvTm9kZS5ub2RlVmFsdWUpIHtcbiAgICAgICAgICAgIG1vcnBoZWROb2RlLm5vZGVWYWx1ZSA9IHRvTm9kZS5ub2RlVmFsdWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG1vcnBoZWROb2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRleHQgbm9kZSB0byBzb21ldGhpbmcgZWxzZVxuICAgICAgICAgIG1vcnBoZWROb2RlID0gdG9Ob2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1vcnBoZWROb2RlID09PSB0b05vZGUpIHtcbiAgICAgIC8vIFRoZSBcInRvIG5vZGVcIiB3YXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgXCJmcm9tIG5vZGVcIiBzbyB3ZSBoYWQgdG9cbiAgICAgIC8vIHRvc3Mgb3V0IHRoZSBcImZyb20gbm9kZVwiIGFuZCB1c2UgdGhlIFwidG8gbm9kZVwiXG4gICAgICBvbk5vZGVEaXNjYXJkZWQoZnJvbU5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodG9Ob2RlLmlzU2FtZU5vZGUgJiYgdG9Ob2RlLmlzU2FtZU5vZGUobW9ycGhlZE5vZGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbW9ycGhFbChtb3JwaGVkTm9kZSwgdG9Ob2RlLCBjaGlsZHJlbk9ubHkpO1xuXG4gICAgICAvLyBXZSBub3cgbmVlZCB0byBsb29wIG92ZXIgYW55IGtleWVkIG5vZGVzIHRoYXQgbWlnaHQgbmVlZCB0byBiZVxuICAgICAgLy8gcmVtb3ZlZC4gV2Ugb25seSBkbyB0aGUgcmVtb3ZhbCBpZiB3ZSBrbm93IHRoYXQgdGhlIGtleWVkIG5vZGVcbiAgICAgIC8vIG5ldmVyIGZvdW5kIGEgbWF0Y2guIFdoZW4gYSBrZXllZCBub2RlIGlzIG1hdGNoZWQgdXAgd2UgcmVtb3ZlXG4gICAgICAvLyBpdCBvdXQgb2YgZnJvbU5vZGVzTG9va3VwIGFuZCB3ZSB1c2UgZnJvbU5vZGVzTG9va3VwIHRvIGRldGVybWluZVxuICAgICAgLy8gaWYgYSBrZXllZCBub2RlIGhhcyBiZWVuIG1hdGNoZWQgdXAgb3Igbm90XG4gICAgICBpZiAoa2V5ZWRSZW1vdmFsTGlzdCkge1xuICAgICAgICBmb3IgKHZhciBpPTAsIGxlbj1rZXllZFJlbW92YWxMaXN0Lmxlbmd0aDsgaTxsZW47IGkrKykge1xuICAgICAgICAgIHZhciBlbFRvUmVtb3ZlID0gZnJvbU5vZGVzTG9va3VwW2tleWVkUmVtb3ZhbExpc3RbaV1dO1xuICAgICAgICAgIGlmIChlbFRvUmVtb3ZlKSB7XG4gICAgICAgICAgICByZW1vdmVOb2RlKGVsVG9SZW1vdmUsIGVsVG9SZW1vdmUucGFyZW50Tm9kZSwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghY2hpbGRyZW5Pbmx5ICYmIG1vcnBoZWROb2RlICE9PSBmcm9tTm9kZSAmJiBmcm9tTm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICBpZiAobW9ycGhlZE5vZGUuYWN0dWFsaXplKSB7XG4gICAgICAgIG1vcnBoZWROb2RlID0gbW9ycGhlZE5vZGUuYWN0dWFsaXplKGZyb21Ob2RlLm93bmVyRG9jdW1lbnQgfHwgZG9jKTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHdlIGhhZCB0byBzd2FwIG91dCB0aGUgZnJvbSBub2RlIHdpdGggYSBuZXcgbm9kZSBiZWNhdXNlIHRoZSBvbGRcbiAgICAgIC8vIG5vZGUgd2FzIG5vdCBjb21wYXRpYmxlIHdpdGggdGhlIHRhcmdldCBub2RlIHRoZW4gd2UgbmVlZCB0b1xuICAgICAgLy8gcmVwbGFjZSB0aGUgb2xkIERPTSBub2RlIGluIHRoZSBvcmlnaW5hbCBET00gdHJlZS4gVGhpcyBpcyBvbmx5XG4gICAgICAvLyBwb3NzaWJsZSBpZiB0aGUgb3JpZ2luYWwgRE9NIG5vZGUgd2FzIHBhcnQgb2YgYSBET00gdHJlZSB3aGljaFxuICAgICAgLy8gd2Uga25vdyBpcyB0aGUgY2FzZSBpZiBpdCBoYXMgYSBwYXJlbnQgbm9kZS5cbiAgICAgIGZyb21Ob2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG1vcnBoZWROb2RlLCBmcm9tTm9kZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vcnBoZWROb2RlO1xuICB9O1xufVxuXG52YXIgbW9ycGhkb20gPSBtb3JwaGRvbUZhY3RvcnkobW9ycGhBdHRycyk7XG5cbmV4cG9ydCBkZWZhdWx0IG1vcnBoZG9tO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///f5ad1795\n");

/***/ })

}]);